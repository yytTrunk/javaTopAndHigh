# MySQL基础

## 一. 基础

### 1.1 MySQL存储引擎有哪些？有什么特点。

MySQL核心在于插件式存储引擎，存储引擎是基于表，开发者可以按照自己意愿进行开发，不同存储引擎具备不同的特点，包含InnoDB、MyISAM等。

- InnoDB存储引擎

InnoDB支持事务，强制要求有主键，支持外键，高并发、大数据量（通过分库分表、读写分离），高可用（主备切换）。

现在版本（5.5.8开始）默认存储引擎为InnoDB，使用比较成熟，常用。

- MyISAM存储引擎

不支持事务，不支持外键，支持全文索引，索引文件与数据文件分开，索引文件位于内存中，查询性能较好，适用于多查询的需求。

为表锁设计，并发写，性能差一些。



### 1.2 MySQL数据库支持锁类型有哪些？

包含表锁（MyISAM）、页锁，行锁（InnoDB）。



### 1.3 InnoDB支持哪些锁？

**InnoDB的行锁**分为共享锁（S）和排他锁（X）

共享锁：允许事务读取一行数据，即允许多个事务加共享锁，来读取同一条数据，但是其它事务不能来写这行数据。

排他锁：允许事务删除或更新一条数据，即只允许一个事务来写这行数据，其它事务可以进行读。

**InnoDB的意向锁，即表级别锁**，事务能够获得多行的排他锁或者共享锁。

当执行insert、update 、delete命令时，会自动给所修改行加入行级排他锁。select不会加锁。

InnoDB锁用来保证，一行数据，当有事务进行修改时，其它人不能修改，只能进行读。



### 1.4 InnoDB中死锁？如何解决？

**死锁概念**

事务A持有行1的锁，想要去获取事务B持有的行2的锁，同时事务B持有行2的锁，想去获取事务A持有行1的锁，事务A与事务B互相等待，造成死锁。

**解决死锁**

1） 采用超时，当互相等待时，一方超时，直接回滚，另一方可以继续执行

2）查看日志，找到对应死锁位置，分析代码避免



### 1.5 MySQL中索引的原理是什么？

索引的目的是为了提高查询效率。

MySQL中最常用索引为B+树索引，其底层数据结构是B+树。B+树索引分为聚簇索引和非聚簇索引。

**B+树索引查询流程**   首先根据索引查找到所查找数据行所在的页，然后数据库把页中数据读入内存中，再在内存中进行查找，最终拿到需要查找的数据。并不是通过索引直接查找到所需要查找的元素。



### 1.8 MyISAM的索引实现原理？

MyISAM存储引擎，索引文件与数据文件分开，索引文件位于内存中。索引文件依据B+ 树存储，索引key对应值为地址，对应数据文件中数据。查找时，先从内存中，查找索引文件找到地址，再从数据文件中查找对应数据。



### 1.9 B+树数据结构有什么特点？

B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，是一种平衡查找树。

B+树中，记录节点按照键值的大小顺序放在同一层叶子节点上。如下B+树，高度为2，每页可存放4条记录。所有记录都在叶子节点，顺序存放。

当出入元素28时，由于LeafPage和IndexPage都没有满，直接插入即可。

![](.\img\01_01.png)

**特点** B+树总会保持平衡，因此在插入元素时，会进行拆分页。

B+树索引中对应节点存入的元素都在叶子节点上，即内部节点25,50,75只存储索引key，不存储元素值data。同时在叶子节点上，加了顺序访问指针，便于顺序查找。



### 1.10 B+树和B-树有什么区别？

1）B+树的非叶子节点只存储键值信息

2）B+树的所有叶子节点之间存在指针，便于范围查找

3）B+树的存储数据值都在叶子节点中



### 1.11 聚簇索引和非聚簇索引有什么区别？

B+树索引分为聚集索引和非聚集索引。

**聚集索引**  InnoDB，数据文件就是就是索引文件，默认使用主键作为索引，称为聚簇索引。

如果采用非主键值作为索引，此时索引中元素对应的value值为主键值，查找时，会先在对应非主键值的索引中，查找到元素对应的主键，然后再在数据文件的聚集索引中，查找到对应元素。

因此，一般InnoDB中，都建议采用自增值作为主键。自增值，在插入元素时，只需要顺序插入新节点，避免了树的旋转再进行拆分页。

**非聚集索引** MyISAM，数据文件与索引文件分开。索引文件中存储的值为对应数据文件中的地址。



### 1.12 什么情况适合使用索引？

1）创建索引需要占用磁盘空间，索引在本质上通过空间换取时间

2）频繁修改索引，会降低性能，同时索引越多，需要修改的越多

因此，不建议创建过多索引，一张表，建立1-2个索引。



### 1.13 事务包含哪几个特性？

四个特性ACID

原子性（atomicity）：事务里的一系列操作，要么一起执行成功，如果某个操作执行失败，则全部会失败，事务执行会失败；

一致性（consistency）：指数据一致性，执行事务是对数据库状态从一种状态转变为另一种状态，不能在执行事务前后，数据库完整性出现变化。比如，事务对数据表中的主键ID进行修改，事务执行成功或者回滚后，主键ID被修改，不再唯一，导致数据库状态发生变化。

隔离性（isolation）：指多个事务之间的操作不能互相影响，同一时间，只允许一个事务请求同一数据；

持久性（durability）：指事务执行完成后，能够持久有效，不能过段时间，自己消失掉或者又恢复为以前。



### 1.14 MySQL支持哪几种事务隔离级别？

**读未提交（read-uncommitted）**：一个事务可以读取到另一个事务里未提交的数据

**读已提交（也称不可重复读）（read-committed）**：一个事务在读取另一个事务里修改到的数据，需要等到另一个事务将数据修改提交后，才能读取到。例如：事务A读取到表中某个数据值为A，当事务B对该数据进行修改，修改为B，此时再提交，那么事务A再读取该数据，得到的值为B，即能够读取到其它事务已提交的数据，不能读取到未提交的数据。相对于读未提交，稍显严格一点。（能够解决脏读）

**可重复读（repeatable-read）**：一个事务开始后，读取某个数据值为A，无论读取多少次都为A，即使其它事务对该值进行了修改，无论修改是否提交。（能够解决不可重复读）

**串行化（serializable）**：多个事务执行，串行化执行，一个事务执行，需要等到上个事务执行完成，才能执行，不能并行执行。（能够解决幻读）



### 1.15 事务隔离级别能够解决哪些问题？

事务的执行存在脏读、不可重复读和幻读的问题。

**脏读**：事务A读取到了另一个事务B里修改的值，未提交，最终事务B回滚了，导致事务A读取到数据为脏数据

**不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致

**幻读**：针对插入，一个事务A将表中所有行的某个字段修改为A，此时另一个事务B插入了一条数据并提交，数据中的某个字段并没有被修改过。导致事务A的执行出现了幻觉，修改不完全。

不能事务隔离级别能够解决的问题

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

InnoDB存储引擎，默认事务隔离级别为可重复读（repeatable-read）。



### 1.16 不同事务隔离级别的底层实现原理是什么？

MySQL使用的MVCC（多版本并发控制）实现可重复读。

通过在每行记录后面保存两个隐藏列来实现。隐藏列一个用来存储记录创建时间，一个用来记录记录删除时间，即通过这两个值来表示这条记录属于哪个版本。此处存储的值并不为时间，为对应事务的ID。每次更新该记录中数据时，会新增记录，但是主键还是一致的，只是保存到不同版本中，当进行查询时，返回不同版本的数据即可。

当事务ID为18的事务，进行查询时，只会返回隐藏列中创建事务ID小于等于18的数据，从而保证不同事务重复多次读数据一致。

```
// 如表中数据
id   name  age  创建事务ID  删除事务ID
1    tom   12    18
1    tom   20    20
```

MVCC只在可重复读和不可重复读两个隔离级别中使用，通过该种方式，可以不用加锁操作，查询性能更好，但是需要额外保存多个版本的数据，带来了存储空间的开销。

读未提交，只需要每次都读取最新数据，不需要进行版本控制。

串行化通过对所有读取行加锁实现。



## 二 提高

### 2.1 一条SQL语句是如何执行的？









## 三 调优

### 3.1 MySQL如何调优？

通常情况下，SQL查询最好为单表查询，多表处理逻辑使用Java代码处理，此时只用考虑查询耗时问题。如果查询慢，可以添加索引，同时在查询时用到该索引，从而提高效率。可以通过查看MySQL的执行计划，查看慢SQL是否使用到了索引。此种只为基础的回答方式。
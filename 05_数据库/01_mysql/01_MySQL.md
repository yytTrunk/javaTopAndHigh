# MySQL基础

## 一. 基础

### 1.1 MySQL存储引擎有哪些？有什么特点。

MySQL核心在于插件式存储引擎，存储引擎是基于表，开发者可以按照自己意愿进行开发，不同存储引擎具备不同的特点，包含InnoDB、MyISAM等。

- InnoDB存储引擎

InnoDB支持事务，强制要求有主键，支持外键约束，高并发、大数据量（通过分库分表、读写分离），高可用（主备切换）。

现在版本（5.5.8开始）默认存储引擎为InnoDB，使用比较成熟，常用。

- MyISAM存储引擎

不支持事务，不支持外键，支持全文索引，索引文件与数据文件分开，索引文件位于内存中，查询性能较好，适用于多查询的需求。

为表锁设计，并发写，性能差一些。

适用于报表系统，一次导入，后面都是大量查询场景。



### 1.2 MySQL数据库支持锁类型有哪些？

包含表锁（MyISAM）、页锁，行锁（InnoDB）。



### 1.3 InnoDB支持哪些锁？

**InnoDB的行锁**分为共享锁（S）和排他锁（X）

共享锁：允许事务读取一行数据，即允许多个事务加共享锁，来读取同一条数据，但是其它事务不能来写这行数据。

排他锁：允许事务删除或更新一条数据，即只允许一个事务来写这行数据，其它事务可以进行读。



**InnoDB的意向锁，即表级别锁**，事务能够获得多行的排他锁或者共享锁。

当执行insert、update 、delete命令时，会自动给所修改行加入行级排他锁。select不会加锁。

InnoDB锁用来保证，一行数据，当有事务进行修改时，其它人不能修改，只能进行读。



> 意向锁是一种`不与行级锁冲突表级锁`，这一点非常重要。意向锁分为两种：
>
> - 意向共享锁
>
>   （intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）
>
>   ```
>   -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
>   SELECT column FROM table ... LOCK IN SHARE MODE;
>   ```
>
> - 意向排他锁
>
>   （intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）
>
>   ```
>   -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
>   SELECT column FROM table ... FOR UPDATE;
>   ```
>
> 即：`意向锁是有数据引擎自己维护的，用户无法手动操作意向锁`，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。
>
> 
>
> 意向锁作用：
>
> - 如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突
>
> - 如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果
>
>   
>
> [详解 MySql InnoDB 中意向锁的作用](https://juejin.cn/post/6844903666332368909)



查询操作select，默认不会主动加锁，因为InnoDB默认实现了可重复读，采用了MVCC机制，

多个事务进行读取数据，不会出现重复。

但是也可以进行手动加锁。

手动加共享锁   select * from table where id = 1 lock in share mode

手动加排他锁  select * from table where id = 1 for update 

此时其它事务会进行等待。



**间隙锁**

幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。锁的就是两个值之间的空隙。

在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的。



间隙锁是在可重复读隔离级别下才会生效的

当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。

没有建立索引或者是非唯一索引时，则语句会产生间隙锁。

**间隙的范围**

根据检索条件向下寻找最靠近检索条件的记录值A作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。





### 1.4 MySQL 中乐观锁与悲观锁

悲观锁：每次操作都担心其它操作会同步修改，都进行加锁select * from table where id = 1 for update 

乐观锁：比较乐观，不进行加锁，在修改数据前，先查询一次，接着再执行update操作，update是比较下版本号，是否还是前一次select到的版本号，如果是就进行修改。如果一样就进行修改，然后版本号加1，否则就不进行更新，然后重写进行查询再更新。



一般不建议使用悲观锁，存在死锁风险。

### 1.5 InnoDB中死锁？如何解决？

**死锁概念**

事务A持有行1的锁，想要去获取事务B持有的行2的锁，同时事务B持有行2的锁，想去获取事务A持有行1的锁，事务A与事务B互相等待，造成死锁。

**解决死锁**

1） 采用超时，当互相等待时，一方超时，直接回滚，另一方可以继续执行

2）查看日志，找到对应死锁位置，分析代码避免



### 1.5 MySQL中索引的原理是什么？

索引的目的是为了提高查询效率。

MySQL中最常用索引为B+树索引，其底层数据结构是B+树。B+树索引分为聚簇索引和非聚簇索引。

**B+树索引查询流程**   

首先根据索引查找到所查找数据行所在的页，然后数据库把页中数据读入内存中，再在内存中进行查找，最终拿到需要查找的数据。并不是通过索引直接查找到所需要查找的元素。



为什么使用B树	

Ｂ树出现是因为磁盘IO。IO操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘IO操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。
所以，为了减少磁盘IO的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。



### 1.8 MyISAM的索引实现原理？

MyISAM存储引擎，索引文件与数据文件分开，索引文件位于内存中。索引文件依据B+ 树存储，索引key对应值为地址，对应数据文件中数据。查找时，先从内存中，查找索引文件找到地址，再从数据文件中查找对应数据。





### 1.9 B+树数据结构有什么特点？

B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，是一种平衡查找树，是多路查找树。

B+树中，记录节点按照键值的大小顺序放在同一层叶子节点上。如下B+树，高度为2，每页可存放4条记录（指树的分叉树）。所有记录都在叶子节点，顺序存放。

当出入元素28时，由于LeafPage和IndexPage都没有满，直接插入即可。

![](.\img\01_01.png)

**B+树特点** 

- B+树索引中对应节点存入的元素都在叶子节点上，即内部节点25,50,75只存储索引key，不存储元素值data。（这样可以存储更多的节点元素，可以使得B+树比B树更加矮胖，查询时IO次数更少）

- 同时在叶子节点上，加了顺序访问指针，便于范围查找。
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

- 叶子节点点本身依关键字的大小自小而大顺序链接。

- B+树总会保持平衡，因此在插入元素时，会进行拆分页。



**B+树查询过程**

单元素查询，B+树自顶向下逐层查找，最终找到匹配的叶子节点。

范围查询，找到下限的节点位置，通过链表指针进行遍历



采用B+树

- 非叶子节点不存data，只存储索引（冗余），可以放更多的索引。
- 非叶子节点包含所有索引字段
- 叶子节点用指针连接，提高区间访问的性能，便于范围查询
- 插入或者删除元素都会导致节点发生裂变反应，来保持平衡



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200820093629917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjIzNTY1,size_16,color_FFFFFF,t_70#pic_center)

[Mysql索引B+树，索引优化](https://blog.csdn.net/qq_32223565/article/details/108116736)



### 1.10 B+树和B-树有什么区别？

1）B+树的非叶子节点只存储键值信息，因此可以放更多的索引，B-树是都存储键值信息的，

2）B+树的所有叶子节点之间存在指针，便于范围查找

3）B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。



**B+树的优势：**

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。



### 1.11 聚簇索引和非聚簇索引有什么区别？

B+树索引分为聚集索引和非聚集索引。

**聚集索引**  InnoDB，数据文件就是索引文件，默认使用主键作为索引，称为聚簇索引。

InnoDB中要求必须有主键

如果采用非主键值作为索引，此时索引中元素对应的value值为主键值，查找时，会先在对应非主键值的索引中，查找到元素对应的主键，然后再在数据文件的聚集索引中，查找到对应元素。

因此，一般InnoDB中，都建议采用自增值作为主键。自增值，在插入元素时，只需要顺序插入新节点，避免了树的旋转再进行拆分页。

**非聚集索引** MyISAM，数据文件与索引文件分开。索引文件中存储的值为对应数据文件中的地址。



### 1.12 什么情况适合使用索引？

1）创建索引需要占用磁盘空间，索引在本质上通过空间换取时间，会增加磁盘消耗

2）频繁修改索引，会降低性能，同时索引越多，需要修改的越多

因此，不建议创建过多索引，一张表，建立1-3个索引。

选择哪些值作为索引

需要查看该字段，在总行数中的占比，不能是该字段，多数都为相同值，导致使用完索引查询后，还有大量数据需要进行过滤，那么与不创建索引，就几乎没有差别。因此，每个值，几乎都不太一样，那么使用索引，效率就会更高



### 1.13 索引使用规则？

当需要使用多个参数进行查询时，如SQL语句select * from db where id1=1 and  id2=2 and id3=3  时，可以使用联合索引。

联合索引将多个字段组合为一个联合索引，如id1,id3，id3

1）全列匹配

三个条件都能使用索引

2）最左前缀匹配

联合索引，最左边一个或连续几个可以使用索引

3）最左前缀匹配，中间值没匹配

如使用到了联合索引的第一列，和第三列，但是第二列没有使用到索引。

select * from db where id1=1 and id3=3

此时先使用第一列索引进行查找，然后进行扫描过滤一次，找到id3=3。

4) 没有最左匹配

select * from db where id2=3

此时也不会走索引

5) 前缀匹配

如果是like，只能是like 'XX%'才能使用索引

select * from db where id1 =1 and id2='22%'

6) 范围列查询

范围查询（>=  <=）操作，是能够利用查询，但是范围之后操作就不会走索引了

select * from db where id1>=1 and id2=2

7) 包含函数

如果使用了函数，那一列将不使用索引

select * from db where id1=1 and 函数(id2)=2

id1会使用索引，但是函数不会使用索引



### 1.14 事务包含哪几个特性？

四个特性ACID

原子性（atomicity）：事务里的一系列操作，要么一起执行成功，如果某个操作执行失败，则全部会失败，事务执行会失败；

一致性（consistency）：指数据一致性，执行事务是对数据库状态从一种状态转变为另一种状态，不能在执行事务前后，数据库完整性出现变化。比如，事务对数据表中的主键ID进行修改，事务执行成功或者回滚后，主键ID被修改，不再唯一，导致数据库状态发生变化。

隔离性（isolation）：指多个事务之间的操作不能互相影响，同一时间，只允许一个事务请求同一数据；

持久性（durability）：指事务执行完成后，能够持久有效，不能过段时间，自己消失掉或者又恢复为以前。



AID一起带来了C。

### 1.15 MySQL支持哪几种事务隔离级别？

**读未提交（read-uncommitted）**：一个事务可以读取到另一个事务里未提交的数据

**读已提交（也称不可重复读）（read-committed）**：一个事务在读取另一个事务里修改到的数据，需要等到另一个事务将数据修改提交后，才能读取到。例如：事务A读取到表中某个数据值为A，当事务B对该数据进行修改，修改为B，此时再提交，那么事务A再读取该数据，得到的值为B，即能够读取到其它事务已提交的数据，不能读取到未提交的数据。相对于读未提交，稍显严格一点。（能够解决脏读）

**可重复读（repeatable-read）**：一个事务开始后，读取某个数据值为A，无论读取多少次都为A，即使其它事务对该值进行了修改，无论修改是否提交。（能够解决不可重复读）

**串行化（serializable）**：多个事务执行，串行化执行，一个事务执行，需要等到上个事务执行完成，才能执行，不能并行执行。（能够解决幻读）



### 1.16 事务隔离级别能够解决哪些问题？

事务的执行存在脏读、不可重复读和幻读的问题。

**脏读**：事务A读取到了另一个事务B里修改的值，未提交，最终事务B回滚了，导致事务A读取到数据为脏数据

**不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致

**幻读**：针对插入，一个事务A将表中所有行的某个字段修改为A，此时另一个事务B插入了一条数据并提交，数据中的某个字段并没有被修改过。导致事务A的执行出现了幻觉，修改不完全。

不同事务隔离级别能够解决的问题

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

InnoDB存储引擎，默认事务隔离级别为可重复读（repeatable-read）。



### 1.17 不同事务隔离级别的底层实现原理是什么？

MySQL使用的MVCC（多版本并发控制）实现可重复读。

通过在每行记录后面保存两个隐藏列来实现。隐藏列一个用来存储记录创建时间，一个用来记录记录删除时间，即通过这两个值来表示这条记录属于哪个版本。此处存储的值并不为时间，为对应事务的ID。每次更新该记录中数据时，会新增记录，但是主键还是一致的，只是保存到不同版本中，当进行查询时，返回不同版本的数据即可。

当事务ID为18的事务，进行查询时，只会返回隐藏列中创建事务ID小于等于18的数据，从而保证不同事务重复多次读数据一致。

```
// 如表中数据
id   name  age  创建事务ID  删除事务ID
1    tom   12    18
1    tom   20    20
```

MVCC只在可重复读和不可重复读两个隔离级别中使用，通过该种方式，可以不用加锁操作，查询性能更好，但是需要额外保存多个版本的数据，带来了存储空间的开销。

读未提交，只需要每次都读取最新数据，不需要进行版本控制。

串行化通过对所有读取行加锁实现。



## 二 提高

### 2.1 一条SQL语句是如何执行的？











## 三 数据库分库分表

### 3.1 为什么要分库分表？使用哪些中间件进行分库分表？各具备哪些优缺点？

单表700万，超过1000万，最好分库分表

假如存在一个单机数据库，表中3000万数据，高峰8000个请求，每天新增数据量120万

#### 单击MySQL存在问题原因： 

1. MySQL单机，磁盘容量不够
2. MySQL单击，扛不住高并发
3. MySQL单表数据量大，SQL慢

#### 分库之后优点

 	1. MySQL从单机，分为3个库，那么可以承受的并发增加了3倍
 	2. 3个库，每个库容量降为了1/3，磁盘使用率降低
 	3. 原来一个单表3000万数据，查询一个SQL 3s，现在拆分之后，每个表1000万数据，SQL查询时间也缩短

#### 分库分表有哪些中间件

数据库中间件，在数据分发时，能够确定将数据分发至哪个数据库中。

如下使用较多

- sharding-jdbc 

  client层方案，支持分库分表，读写分离，分布式id生成，柔性事务（最大努力推送，TCC事务）

  不需要额外去部署，但是如果升级需要每个使用者都升级

- mycat

  proxy层方案，也挺好

  需要部署，进行运维

### 3.2 如何进行水平拆分？垂直拆分？

- 垂直拆分（一般在数据库设计时进行）

  将一个表中多个字段进行拆分，将常用字段拆分到一个表中

- 水平拆分（常用）

  每个表中放一部分数据，比如1000万表进行拆分

  可以使用唯一ID进行hash取模（11%3）分到不同的库，下不同的表上面。

  或者根据时间，如何1月数据写在一个表，2月写在另外一个表



两种方式

- 一种按照range来分：每个表存储一段连续的数据，可以是按照时间。较少使用。

  因为热点数据，通常是新插入数据，请求量还是高，会集中在这一个表上。

  扩容方便

- 一种按照hash分发（常用），平均分配每个库的数据量和请求压力。

  扩容不方便，需要进行数据迁移

 

### 3.3 如何设计不停机把系统向未分库分表动态切换到分库分表上？

- 方案1: 停机维护进行动态迁移

  停机后，编写独立程序，从原有数据库表中进行数据读取，通过数据库中间件，写向数据库。

  完成后，重新启动，使用数据库中间件进行数据库操作。

  缺点：需要停机

- 方案2：不停机，双写方案

  数据请求后，进行双写，单库单表写入，分库分表也写入

  再通过后台数据迁移程序，将单库单表中数据，通过数据库中间件写入到分库分表中。写入时需要先从分库分表中，进行读取，判断数据是否已存在，如果存在，需要比较哪边数据较新。

  完成后，判断两边数据是否一模一样。

  后台程序可以连续多跑一段时间，如果分库不再写入数据，就可以了。

  然后修改程序，不再使用单库单表。

  

### 3.4 如何设计可以动态扩容的分库分表方案？





### 3.5 分库分表之后，id主键如何处理？







## 四 调优

### 4.1 MySQL如何调优？

通常情况下，SQL查询最好为单表查询，多表处理逻辑使用Java代码处理，此时只用考虑查询耗时问题。如果查询慢，可以添加索引，同时在查询时用到该索引，从而提高效率。可以通过查看MySQL的执行计划，查看慢SQL是否使用到了索引。此种只为基础的回答方式。

执行计划

explain select * from table



**数据选型：**首先是数据选型方面进行优化，选取最适用的字段属性，数据的表越小，查询越快 

**范式应用：**合理使用范式和反范式 

**存储引擎的选择：**如果该数据库读操作较多，存储引擎选择MyISAM，如果是写操作多，选择innodb 

**主键选择：**代理主键 

**执行计划explain：**使用explain+sql测试sql语句执行情况，然后优化sql语句 

1.  注意的关键字：type关键字，通常达到range级别，最好是ref，而ref最好是一个常数。 

 **索引优化：** 

1.  尽量在主键上添加使用索引 
2.  利用覆盖索引、索引下推机制，注意组合索引的匹配原则， 
3.  尽量使用唯一索引，避免使用普通索引 

**查询优化：**这个应该被包含在执行计划中，但是个人觉得还是拆出来，其实我们在写的时候就该注意sql的效率，explain执行计划只是验证 

1.  优化数据访问，避免查询中出现筛选大量数据，可以通过limit限制； 
2.  避免select * from table这种全表扫描的语句 
3.  如果业务没有特殊规定数据，那么就尽量避免使用UNION，可以考虑UNION-ALL替换，因为后者不会过滤重复数据，效率高于UNION



[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)



### 4.2 通常数据库索引使用方案

尽量使用单表来增删改查，降低SQL复杂度

通常再配上主键索引和少数几个联合索引，基本就够用了。

尽量不要使用SQL来进行计算，函数，子查询等。使用Java代码去实现逻辑。











<<<<<<< Updated upstream
## 树的结构

### 什么是二叉查找树

二叉查找树（BST）具备什么特性？

1.**左**子树上所有结点的值均**小于或等于**它的根结点的值。

2.**右**子树上所有结点的值均**大于或等于**它的根结点的值。

3.左、右子树也分别为二叉排序树。

采用二分查找的思想，查找所需最大的次数等于树的高度

![img](https://pic1.zhimg.com/80/v2-a346782e1ad8ede7d328dddb8a7e76b4_720w.jpg)

**存在不足** 多次插入新节点，会导致不平衡

![img](https://pic1.zhimg.com/80/v2-38e1125c3caa7bc83723f70f28533638_720w.jpg)

因此，出现红黑树



### 什么是平衡树

AVL树是高度平衡的而二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 通常AVL树是在二叉搜索树上，经过局部调整而建立的，因此，它还是一棵排序树。



### 什么是红黑树

红黑树是一种自平衡的二叉查找树。

具备特点

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![img](https://pic3.zhimg.com/80/v2-a183459a6010189e8b2b9415d85e550e_720w.jpg)

因为这些规则，保证了树的自平衡。

当插入或删除节点时，红黑树的规则可能会被打破，这时就会通过左旋、右旋、变色来保证平衡。

**应用**

TreeMap  TreeSet   HashMap

[什么是红黑树？](https://zhuanlan.zhihu.com/p/31805309)
=======


>>>>>>> Stashed changes

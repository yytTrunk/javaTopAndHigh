# redis

[TOC]



## 一 为什么要用redis？

redis(Remote Dictionary Server 远程字典服务器)。

主要应用于缓存和队列

#### redis特点

1. **支持数据类型丰富**，string，hash，list，set，sorted set
2. **高性能**，Redis 数据库中的所有数据都存储在内存中，读写速度快。
3. **支持持久化**，同时还可以将数据异步写入到硬盘 中，保证数据持久化
4. **使用简单**，提供了100多个命令，并且开源



## 二 为什么要使用缓存？

缓存能够用来实现高性能和高并发

1. 提高性能，大量用户请求数据查询，第一次需要从数据库里读取，然后写入缓存中，后面请求只需要从缓存里读取即可，避免每次查询都需要从数据库中读取，速度更快
2. 提高并发，缓存存放于内存，读取数据更快，并发量更高



## 三 redis支持哪几种数据类型？

  1. **String 字符串类型**，一个字符串类型键允许存储最大容量为512M。其实其它数据类型可以理解均为字符串类型的组织形式不同。

     底层存储原理

  2. **hash(字典) 散列类型**，采用键值对存储。适合存储对象，使用对象类别和ID构成键名，使用字段表示属性。例如，存储文章数据。

  3. **list 列表类型**，存储有序字符串列表，基于双向链表实现，向列表两端插入元素快，获取靠近两段元素快。例如，记录日志，不会受到日志总条数影响；存储文章ID、评论列表。

  4. **set 集合类型**，采用值为空的散列表（hash table）实现，无序集合、自动去重。例如，存储文章标签。（其底层数据结构类似于Java中HashMap）

  5. **sorted set 有序集合类型**，在set集合类型基础上，变得有序，基于散列表和跳跃表实现。与list列表类型的底层实现原理不同。例如，按点击率排序

![redis数据结构](.\img\02_01.PNG)



## 四 redis核心原理

### 4.1 redis单线程如何处理多个并发客户端的连接？

redis是利用epoll实现IO多路复用，当多个客户端请求或事件过来时，将连接信息和事件放到队列中。每个操作会对应不同的事件，依次连接事件放到事件分派器上，事件分派器将事件分发到对应事件处理器上。

事件处理器包括，连接应答处理器、命令请求处理器、命令回复处理器。

![redis多路复用](.\img\02_02.PNG)

当客户端创建socket，与redis建立连接时，携带事件会由文件事件分派器分发至连接应答处理器处理；

当客户端向redis发送命令请求时，携带事件会由文件事件分派器分发至命令请求处理器处理；

当处理完成后，并且客户端准备好读取响应数据时，向redis发送请求，携带事件会由文件事件分派器分发至命令回复处理器处理，返回执行结果。

补充：命令实现函数将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。



Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

- 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。



#### IO多路复用 - epoll机制

多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），

CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。



采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。

> epoll原理
>
> 两点：共享内存、事件就绪通知机制
>
> epoll采用的是将多个socket连接，存放在内核与应用程序共有的内存中（mmap 共享了用户和内核的部分空间，避免了数据的来回拷贝），采用的事件就绪通知机制，不是轮询机制（指应用层主动去向内核轮询询问每个套接字是否完成）。
>
> epoll 基于事件驱动，epoll_ctl 注册事件并注册 callback 回调函数，epoll_wait 只返回发生的事件，避免了像 select 和 poll 对事件的整个轮寻操作。
>
> [epoll原理](https://blog.csdn.net/daaikuaichuan/article/details/83862311)

### 4.2 redis是单线程，为什么还那么快？

1. redis中数据都存储在内存中，读取写入速度更快，可以达到ns级别，单台理论最多达到QPS ,10W 
2. 单线程避免了多线程的切换，因此不建议使用耗时较长的命令，如keys命令
3. 基于epoll实现IO多路复用，来高效处理多个客户端请求，将请求都压入队列中，同时事件处理器都是基于内存来操作，处理速度快

### 4.3 redis如何进行持久化？两种方式如何选择？

持久化是指Redis能够将数据从内存中同步到硬盘中，使得重启后仍然能够根据硬盘中记录恢复数据。

redis支持两种方式的持久化，RDB和AOF。

#### RDB(Redis DataBase）

**采取方式**  定时将内存中的数据生成一份副本同步到硬盘上，该过程称为快照。默认保存在dump.rdb二进制文件中。采用N秒内有M个改动时，会生成快照。

**存在问题** 采用N秒内有M个改动时，当操作不满足M次时，如60s内有1000次操作，生成快照，当为999次，结束，此时会造成数据丢失。

#### AOF (Append Only File)

**采取方式** 每次执行命令后，将命令本身记录下来。当redis重新启动时，会重新执行AOF文件的命令，达到redis启动前的状态。可以配置多久将修改的命令写入文件中，即多久执行一次fsync命令将命令写入硬盘中。

**推荐** 也是默认，每秒fsync一次，此时能够兼顾速度和安全。

**存在问题** 当存入命令过多时，重新启动redis，速度会比较慢。

#### 两种方式如何选择？

**RDB** 快照方式备份数据库，启动较快，但会数据丢失

**AOF** 不会造成数据丢失，但是存入命令过多时，重新启动redis，速度会比较慢

**因此，在redis4.0时，支持了混合持久化？**

```java
// 先要开启aof持久化
// 默认不开启，开启命令
aof-use-rdb-preamble yes
```

AOF重写会将记录的多个重复命令进行重写（如set key value，重复了10次，重写后将只记录一次，会加上次数，然后生成新的aof文件）。在重写时，还会将之前的内存rdb快照文件内容和新增的AOF记录的命令，存放在一起，共同写入新的aof临时文件中，写入完成后，生成appendonly.aof文件，覆盖原先存在的aof文件。

重写过程，其它客户端，新增的修改命令，会记录到AOF格式文件中，避免丢失。appendonly.aof包含RDB格式和AOF格式两部分，AOF格式用来记录命令。

AOF能够根据配置在后台自动重写，也可以通过命令bgrewriteaof重写AOF。

**总结** 混合持久化方式实际就是将RDB方式与AOF方式，想办法进行结合，综合两者的优点，RDB的快照，通过补充AOF来记录可能未记录到快照中的命令，然后定时AOF记录的命令，进行重写写入到RDB快照中，从而避免了记录的AOF文件过大，导致redis重新启动耗时长的问题。

### 4.4 redis内存淘汰策略有哪些？

内存淘汰策略能够保证在有限内存中，redis尽可能为热点数据。

**缓存淘汰策略指什么？**

redis数据存放在内存中，内存相对于硬盘，虽然速度快，但是容量有限，如何保证redis中存放数据尽可能为热点数据，使得在有限的内存大小情况下，保证数据访问的速度。此时，可以考虑使用redis的缓存淘汰策略。

当配置redis可用内存后，如果超出内存，会导致redis性能下降，使得redis使用效率下降。可以通过配置参数最大内存maxmemory来限制redis可以存储的容量。当超出后，将执行缓存淘汰策略，redis中包含如下几种淘汰策略，可通过参数maxmemory-policy 配置，默认为noeviction。

- **noeviction** （默认）

不能执行写请求，会报错，只能读取数据，可以保证不会丢失数据，但是redis已经基本丧失了部分功能。

- **volatile-lru** （Iru， Least Recently Used， 最少使用）

尝试淘汰设置了过期时间中最少使用的数据

- **volatile-ttl**

尝试淘汰设置了过期时间，且快要过期的数据，ttl越小越优先被淘汰

- **volatile-random**

尝试淘汰设置了过期时间，随机进行淘汰

- **allkeys-lru**

全体key集合中，使用最少的数据。

- **allkeys-random**

全体key集合中，随机淘汰

**总结**：

1. volatile-XXX，只会淘汰设置了过期时间的数据。allkeys-XXX，针对所有数据。
2. 因此，如果使用了持久化，使用volatile-XXX，能够保证不会过期的数据，能够长时间保存，不会淘汰。
3. 当仅使用redis作为缓存时，没有配置数据过期时间时，可以配置为allkeys-XXX。
4. 通常，更多使用lru

### 4.5 redis中数据过期后，如何进行删除（过期策略）？

采用定期删除和惰性删除机制结合。

**定期删除**，指redis会默认每隔100ms随机抽取设置了过期时间的key，检查是否过期，如果过期就删除。但是如果设置了过期时间的key较多，不可能每个key都去进行检查，会消耗CPU资源，只是随机抽取部分key进行检查删除。

**惰性删除**，在获取某个key时，会去检查一下是否设置了过期时间，是否超时？如果超时就进行删除，不返回过期数据。

采用两种方式结合，保证不会返回已过期的数据。

### 4.6 如何手写LRU算法？

可以基于LinkedHashMap实现。

```java
    public LruMemoryCache(int maxSize) {  
        if (maxSize <= 0) {  
            throw new IllegalArgumentException("maxSize <= 0");  
        }  
        this.maxSize = maxSize;  
        this.map = new LinkedHashMap<String, Bitmap>(0, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > MAX_CACHE_SIZE;
            }
        };  
    }  
```

初始化时设置最大容量。

LinkedHashMap传入第三个参数accessOrder为true，表示按照访问顺序排序，最新访问的会排序在前面。

同时LinkedHashMap存在方法removeEldestEntry，重写该方法。

当超出指定容量时，会删除排序在最后的元素，即被访问最少的元素，因为被访问后会重新排序，放在最前面。



### 4.7 redis如何找到key

单机模型：

Redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中，redisDb.id 存储着 redis 数据库以整数表示的号码。redisDb.dict 存储着该库所有的键值对数据。redisDb.expires 保存着每一个键的过期时间。

当redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number  时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。

在redisDb.dict中，存储着两个哈希表dictht ht[2]，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，

步骤：

二、当redis 拿到一个key 时，如果找到该key的位置。

了解了上述知识之后，我们就可以来分析redis如果在内存找到一个key了。

1、当拿到一个key后， redis 先判断当前库的0号哈希表是否为空，即：if (dict->ht[0].size == 0)。如果为true直接返回NULL。

2、判断该0号哈希表是否需要rehash，因为如果在进行rehash，那么两个表中者有可能存储该key。如果正在进行rehash，将调用一次dictRehashStep方法，dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。

3、计算哈希表，根据当前字典与key进行哈希值的计算。

4、根据哈希值与当前字典计算哈希表的索引值。

5、根据索引值在哈希表中取出链表，遍历该链表找到key的位置。一般情况，该链表长度为1。

6、当 ht[0] 查找完了之后，再进行了次rehash判断，如果未在rehashing，则直接结束，否则对ht[1]重复345步骤。

https://blog.csdn.net/mine_song/article/details/70175881



集群模型（redis cluster）

**Redis Cluster，采用哈希分区规则**，采用虚拟槽分区。

![](.\img\02_03.jpg)

1. Redis Cluster 将所有数据划分为16384 的 slots(槽位)，每个节点负责其中一部分槽位，根据节点个数进行划分，默认等量划分
2. 当需要存储数据时，键值根据CRC16算法计算hash值，然后和槽位总个数16384 按位与，找到对应的槽位，每个节点负责维护一部分槽以及槽所映射的键值数据，因此，集群下redis节点存储数据不重复。
3. 当使用Java客户端Jedis时，客户端会缓存槽位配置信息至客户端本地，客户端要查找某个 key 时，可以直接定位到目标节点，然后直接去操作对应节点

## 五 redis集群模式

### 5.1 什么是哨兵模式

**概念**：使用哨兵工具（sentinel），哨兵为一个独立进程，哨兵通过与redis服务器进行通信，从而监控redis服务器是否正常运行。当哨兵监测到master出现问题，会自动将slave切换成master。

**哨兵作用**：

1. 集群监控，监控redis的master和slave是否正常工作
2. 消息通知，当redis出现故障，能够发送消息通知管理员
3. 故障转移，当master节点出现故障，能够切换到备节点
4. 配置中心，当节点出现故障，能够通知Client使用新的master节点

**缺点**：

1. 哨兵模式，只能有一个主节点对外提供服务，不能在线扩容，难以支持很高并发
2. 主节点容量设置过大，影响恢复和主从切换
3. 当主节点出现问题，主备切换时，这一瞬间，可能会造成不能访问，导致数据不一致问题

导致哨兵模式不再主流使用。该种方式也可以通过搭建多个主从方式解决。

![哨兵模式](.\img\02_05.PNG)

### 5.2 什么是redis高可用集群模式（Redis Cluster）

Redis Cluster是redis官方高可用集群方案

**特点**

由多个主从节点群组成的分布式服务器群，将每个节点设置成集群模式。

- 可扩展性，能够实现水平扩展
- 自动分割数据到不同的节点上，节点自身维护槽的映射关系
- 高可用，整个集群的部分节点失败或者不可达的情况下能够继续处理命令

![JedisCluster](.\img\02_06.PNG)

**数据分布原理** 

分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点 上，每个节点负责整体数据的一个子集。

redis3之后版本，**Redis Cluster，采用哈希分区规则**，采用虚拟槽分区。

![](.\img\02_03.jpg)

1. Redis Cluster 将所有数据划分为16384 的 slots(槽位)，每个节点负责其中一部分槽位，根据节点个数进行划分，默认等量划分
2. 当需要存储数据时，键值根据CRC16算法计算hash值，然后和槽位总个数16384 按位与，找到对应的槽位，每个节点负责维护一部分槽以及槽所映射的键值数据，因此，集群下redis节点存储数据不重复。
3. 当使用Java客户端Jedis时，客户端会缓存槽位配置信息至客户端本地，客户端要查找某个 key 时，可以直接定位到目标节点，然后直接去操作对应节点

**节点通信机制**

采用gossip协议维护集群元数据，所有节点都持有一份元数据，当元数据改变后，会将其发送到其它节点，让其它节点也进行更新。

gossip协议方式特点：所有节点元数据不是集中在一处管理，更新请求较慢，有时延，无中心化。

集中式（如zookeeper）:元数据集中管理，更新读取时效性好。

**网络抖动**

真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。为解决这种问题，Redis Cluster提供了一种选项 cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。

**集群扩容**

gossip协议主要包含ping、pong、meet、fail类型消息等

节点之间会发送ping消息交换元数据信息，就能够知道哪些slot位于哪个节点上

在原有集群上扩容节点，主要通过redis集群提供命令完成，执行流程

1. 新增节点add-node 
2. 重新分片reshard，此时新加节点已经加入到集群中，并且是主节点(Master)，
3. 为新增节点配置从节点replicate

**请求重定向**

当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。

当使用Java客户端Jedis时，客户端会维护槽位配置表，能够通过计算hash，直接找到对应节点，如果没有获取到，会进行同步更新本地操作映射表。

**集群选举**

当slave发现自己的master变为FAIL状态时，便尝试进行Failover，期望成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：

1. slave发现自己的master变为FAIL
2. 将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息
3. 其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack
4. 尝试failover的slave收集FAILOVER_AUTH_ACK
5. 超过半数后变成新Master
6. 广播Pong通知其他集群节点。

从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。

为了避免多个从节点投票相同，集群需要至少有3个主节点。

同时避免同时发起选举，还会有延迟计算公式：

```
DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms
```

SLAVE_RANK表示此slave已经从master复制数据的总量的rank排名，表示slave的更新程度。Rank越小代表已复制的最新数据越多。这种方式下，持有最新数据的slave将会首先发起选举。但是，实际情况还会受网络等因素影响。

### 5.3 主从复制模式（Redis Replication）和高可用模式（Redis Cluster）如何选择？

**主从复制模式（Redis Replication）**，采用主从架构保证高并发，哨兵模式保证高可用。一主多从，单主用来写入数据，多从用来查询，读写分离，从的个数可以根据读的吞吐量来设置。然后再搭建哨兵集群，保证高可用。适用于需要缓存数据量较小，比如几个G。

**高可用模式（Redis Cluster）**：主要针对海量数据、高并发、高可用场景



## 六 redis如何保证高并发、高可用？

redis高并发：采用主从架构，一主多从，单主用来写入数据，多从用来查询，从的个数可以根据读的吞吐量来设置。

redis高可用：采用高可用集群模式，主要针对海量数据、高并发、高可用场景。



## 七 什么是redis缓存雪崩，缓存穿透，缓存失效？如何避免？

#### 缓存雪崩

**是什么** 

并发请求过多，redis无法响应请求，挂掉，大量请求直接访问到数据库（比如20w请求，redis能够支持1w，剩余直接去请求数据库）

**如何避免** 

Step1：保证redis集群高可用，采用多级缓存，接收到请求，先查找本地ehcache缓存，如果不存在再去查找redis，两者都不存在，再去查找数据库，然后将数据库中的结果写入ehcache和redis中

Step2:  限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。

Step3: redis持久化，redis挂掉后，能够快速恢复缓存集群

#### 缓存穿透

**是什么**

采用不存在数据的请求，大量访问，直接穿透一级、二级缓存，去访问数据库，导致缓存失去意义

**如何避免**

布隆过滤器或者对于不存在的数据的请求在redis中存放null值，避免下次再去访问数据库

#### 缓存失效

**是什么**

由于大量缓存失效，同时大量用户访问，

**如何避免** 

可以通过将缓存失效时间设置为范围内的随机数，避免同时大量请求缓存失效



## 八 如何保证缓存和数据库双写数据一致性？

**情景1**： 先更新数据库，然后再去删除缓存，但是删除缓存失败，导致两者数据不一致

**解决** 先删除缓存，再去更新数据库。如果更新数据库失败，缓存中为空，不会造成数据不一致

**情景2**：读写并发情况下对同一数据进行读写，更新数据时，先把缓存删除了，但是在更新数据库期间，还未完成，有请求过来，先请求缓存为空，然后去请求数据库，读取到旧值，又把旧值更新到了缓存中，会导致数据不一致

**解决** 针对修改同一个数据请求操作，进行hash，划分到一个队列中，一个队列对应一个线程。同时，读取数据时，发现数据不在缓存中，也可将重新读取数据和更新缓存操作，发送到同一个队列中，此时一个线程处理该队列中操作，串行化执行。



## 九 如何解决redis并发竞争问题？

**是什么**

多个服务同时并发去更新缓存中同一字段，例如期望顺序为更新1 -> 更新2  -> 更新3 -> 更新4，实际却为更新4 -> 更新1  -> 更新3 -> 更新2，导致不是按照期望顺序执行。

**如何解决**

1. 采用分布式锁来保证同一时刻只能有一个实例去写缓存。

2. 在数据上加入时间戳（例如，从数据库中取出数据时加上时间戳，然后再去更新缓存）。每次进行写的时候，先去判断下准备写入数据的时间戳，是否要早于已经存在缓存中数据，如果早于就不进行写入。

   

## 十 redis基础命令

### 10.1 scan命令

用于迭代当前数据库中的key集合，便于在大规模数据情况下，非阻塞快速查找符合某种规则的key，限制了返回元素个数，时间复杂度o(n)。相比于keys，返回所有符合条件的key，效率更高。

```
SCAN cursor [MATCH pattern] [COUNT count] The default COUNT value is 10.
```

cursor 游标： 记录迭代状态

MATCH：匹配指定格式的元素

COUNT：每次迭代中应该从数据集里返回多少元素

```
scan 0 MATCH * COUNT 2
1) "12"
2) 1) "mylist"
   2) "numn"
scan 0 MATCH * COUNT 5
1) "10"
2) 1) "mylist"
   2) "numn"
   3) "num"
   4) "set2"
   5) "list1"
   6) "kekexpire"
scan 10 MATCH * COUNT 5
1) "7"
2) 1) "key1"
   2) "scoreboard"
   3) "key2"
   4) "bar"
   5) "set1"
scan 7 MATCH * COUNT 5
1) "0"
2) 1) "username"
   2) "car"
   3) "key3"
```

该种方式是因为redis中key的存储是基于hash表，类似于HashMap那样数组+链表的结构。COUNT参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。直到返回0结束。

<img src=".\img\02_04.png" alt="key存储" style="zoom:50%;" />



## 十一 redis基本特性，事务、生成时间、排序、消息队列、管道

### 11.1 redis事务？

redis支持事务，操作都是原子性，是对数据的更改要么全部执行，要么全部不执行。但是redis事务不支持回滚。

例如对于运行时命令，1,2,3, 1执行完，2执行出错，3还是会执行，同时1,3的执行结果都会生效。

##### 命令MULTI、EXEC

包含在MULTI、EXEC间的命令执行完，才能返回各个命令执行结果

##### 命令WATCH

用于一个键或者多个键，一旦其中一个键被修改，之后事务将不再执行，直至执行到EXEC命令。

可以通过使用上述三个命令组合，实现事务操作。

### 11.2 生存时间？

```
// 设置键生存时间
EXPIRE key seconds
```

**应用**  **实现访问频率控制**

设置用户IP为key，1分钟，最大访问次数为100，超过100次提示报错，1分钟到，重新统计

**应用**  **实现缓存**

常使用信息，存入redis，设置生成时间1小时，若超过时间，需要重新读取数据。

同时可以设置参数，配置Redis最大可用内存，避免同时存在键过多，导致占用过大内存，从而制定规则来淘汰部分键。

### 11.3 排序

通过sort命令，能够对集合、列表、有序集合进行排序

通过by，指令某个参数进行排序。

sort时间复杂度O(n+mlogm)， n为列表元素个数，m为要返回元素个数

**提高性能使用原则：**

1. 尽可能减少排序键中元素个数，减小n
2. 使用limit只获取需要数据，减少m
3. 若排序数据量较大，使用store参数将结果缓存

排序底层实现采用**部分快速排序算法**

### 11.4 redis实现消息队列（任务队列）

RPOP命令，能够不断从键中取出元素

BRPOP命令，没有元素会阻塞，直到有元素加入

### 11.5 发布订阅

PUBLISH命令，发布者向指定频道发布消息

SUBSCRIBE命令，接收着从指定频道接收消息

### 11.6 管道

redis server和client通过TCP协议连接，消息来回自server端和client的耗时，称为往返时延。

可通过管道，一次性发送多条命令，在执行完成后一次性将结果返回，减少server和client端的通信次数，降低总体时延。







## 十二  生产环境中的 redis 是怎么部署的？

redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。

机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。

5 台机器对外提供读写，一共有 50g 内存。

因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。

你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。






















# redis

## 一 为什么要用redis？

redis(REmote Dictionary Server 远程字典服务器)。

主要应用于缓存和队列

#### redis特点

1. **支持数据类型丰富**，
2. **高性能**，Redis 数据库中的所有数据都存储在内存中，读写速度快。
3. **支持持久化**，同时还可以将数据异步写入到硬盘 中，保证数据持久化
4. **使用简单**，提供了100多个命令，并且开源



## 二 为什么要使用缓存？

缓存能够用来实现高性能和高并发

1. 提高性能，大量用户请求数据查询，第一次需要从数据库里读取，然后写入缓存中，后面请求只需要从缓存里读取即可，避免每次查询都需要从数据库中读取，速度更快
2. 提高并发，缓存存放于内存，读取数据更快，并发量更高



## 三 redis支持哪几种数据类型？

 	1. **String 字符串类型**，一个字符串类型键允许存储最大容量为512M。其实其它数据类型可以理解均为字符串类型的组织形式不同。
 	2. **hash(字典) 散列类型**，采用键值对存储。适合存储对象，使用对象类别和ID构成键名，使用字段表示属性。例如，存储文章数据。
 	3. **list 列表类型**，存储有序字符串列表，基于双向链表实现，向列表两端插入元素快，获取靠近两段元素快。例如，记录日志，不会受到日志总条数影响；存储文章ID、评论列表。
 	4. **set 集合类型**，采用值为空的散列表（hash table）实现，无序集合、自动去重。例如，存储文章标签。（其底层数据结构类似于Java中HashMap）
 	5. **sorted set 有序集合类型**，在set集合类型基础上，变得有序，基于散列表和跳跃表实现。与list列表类型的底层实现原理不同。例如，按点击率排序

![redis数据结构](.\img\02_01.PNG)



## 四 redis核心原理

### 4.1 redis单线程如何处理多个并发客户端的连接？

redis是利用epoll实现IO多路复用，当多个客户端请求或事件过来时，将连接信息和事件放到队列中。每个操作会对应不同的事件，依次连接事件放到事件分派器上，事件分派器将事件分发到对应事件处理器上。

事件处理器包括，连接应答处理器、命令请求处理器、命令回复处理器。

![redis多路复用](.\img\02_02.PNG)

当客户端创建socket，与redis建立连接时，携带事件会由文件事件分派器分发至连接应答处理器处理；

当客户端向redis发送命令请求时，携带事件会由文件事件分派器分发至命令请求处理器处理；

当处理完成后，并且客户端准备好读取响应数据时，向redis发送请求，携带事件会由文件事件分派器分发至命令回复处理器处理，返回执行结果。

### 4.2 redis是单线程，为什么还那么快？

1. redis中数据都存储在内存中，读取写入速度更快，可以达到ns级别，单台理论最多达到QPS ,10W 
2. 单线程避免了多线程的切换，因此不建议使用耗时较长的命令，如keys命令
3. 基于epoll实现IO多路复用，来高效处理多个客户端请求，将请求都压入队列中，同时事件处理器都是基于内存来操作，处理速度快

### 4.3 redis如何进行持久化？两种方式如何选择？

持久化是指Redis能够将数据从内存中同步到硬盘中，使得重启后仍然能够根据硬盘中记录恢复数据。

redis支持两种方式的持久化，RDB和AOF。

#### RDB

**采取方式**  定时将内存中的数据生成一份副本同步到硬盘上，该过程称为快照。默认保存在dump.rdb二进制文件中。采用N秒内有M个改动时，会生成快照。

**存在问题** 采用N秒内有M个改动时，当操作不满足M次时，如60s内有1000次操作，生成快照，当为999次，结束，此时会造成数据丢失。

#### AOF (append only file)

**采取方式** 每次执行命令后，将命令本身记录下来。当redis重新启动时，会重新执行AOF文件的命令，达到redis启动前的状态。可以配置多久将修改的命令写入文件中，即多久执行一次fsync命令将命令写入硬盘中。

**推荐** 也是默认，每秒fsync一次，此时能够兼顾速度和安全。

**存在问题** 当存入命令过多时，重新启动redis，速度会比较慢。

#### 两种方式如何选择？

**RDB** 快照方式备份数据库，启动较快，但会数据丢失

**AOF** 不会造成数据丢失，但是存入命令过多时，重新启动redis，速度会比较慢

**因此，在redis4.0时，支持了混合持久化？**

```java
// 先要开启aof持久化
// 默认不开启，开启命令
aof-use-rdb-preamble yes
```

AOF重写会将记录的多个重复命令进行重写（如set key value，重复了10次，重写后将只记录一次，会加上次数，然后生成新的aof文件）。在重写时，还会将之前的内存rdb快照文件内容和新增的AOF记录的命令，存放在一起，共同写入新的aof临时文件中，写入完成后，生成appendonly.aof文件，覆盖原先存在的aof文件。

重写过程，其它客户端，新增的修改命令，会记录到AOF格式文件中，避免丢失。appendonly.aof包含RDB格式和AOF格式两部分，AOF格式用来记录命令。

AOF能够根据配置在后台自动重写，也可以通过命令bgrewriteaof重写AOF。

**总结** 混合持久化方式实际就是将RDB方式与AOF方式，想办法进行结合，综合两者的优点，RDB的快照，通过补充AOF来记录可能未记录到快照中的命令，然后定时AOF记录的命令，进行重写写入到RDB快照中，从而避免了记录的AOF文件过大，导致redis重新启动耗时长的问题。

### 4.4 redis内存淘汰策略有哪些？

内存淘汰策略能够保证在有限内存中，redis尽可能为热点数据。

**缓存淘汰策略指什么？**

redis数据存放在内存中，内存相对于硬盘，虽然速度快，但是容量有限，如何保证redis中存放数据尽可能为热点数据，使得在有限的内存大小情况下，保证数据访问的速度。此时，可以考虑使用redis的缓存淘汰策略。

当配置redis可用内存后，如果超出内存，会导致redis性能下降，使得redis使用效率下降。可以通过配置参数最大内存maxmemory来限制redis可以存储的容量。当超出后，将执行缓存淘汰策略，redis中包含如下几种淘汰策略，可通过参数maxmemory-policy 配置，默认为noeviction。

- **noeviction** （默认）

不能执行写请求，会报错，只能读取数据，可以保证不会丢失数据，但是redis已经基本丧失了部分功能。

- **volatile-lru** （Iru， Least Recently Used， 最少使用）

尝试淘汰设置了过期时间中最少使用的数据

- **volatile-ttl**

尝试淘汰设置了过期时间，且快要过期的数据，ttl越小越优先被淘汰

- **volatile-random**

尝试淘汰设置了过期时间，中随机进行淘汰

- **allkeys-lru**

全体key集合中，使用最少的数据。

- **allkeys-random**

全体key集合中，随机淘汰

**总结**：

1. volatile-XXX，只会淘汰设置了过期时间的数据。allkeys-XXX，针对所有数据。
2. 因此，如果使用了持久化，使用volatile-XXX，能够保证不会过期的数据，能够长时间保存，不会淘汰。
3. 当仅使用redis作为缓存时，没有配置数据过期时间时，可以配置为allkeys-XXX。
4. 通常，更多使用lru

### 4.5 redis中数据过期后，如何进行删除（过期策略）？

采用定期删除和惰性删除机制结合。

**定期删除**，指redis会没，默认每隔100ms随机抽取设置了过期时间的key，检查是否过期，如果过期就删除。但是如果设置了过期时间的key较多，不可能每个key都去进行检查，会消耗CPU资源，只是随机抽取部分key进行检查删除。

**惰性删除**，在获取某个key时，会去检查一下是否设置了过期时间，是否超时？如果超时就进行删除，不返回过期数据。

采用两种方式结合，保证不会返回已过期的数据。

### 4.6 如何手写LRU算法？

可以基于LinkedHashMap实现。

```java
    public LruMemoryCache(int maxSize) {  
        if (maxSize <= 0) {  
            throw new IllegalArgumentException("maxSize <= 0");  
        }  
        this.maxSize = maxSize;  
        this.map = new LinkedHashMap<String, Bitmap>(0, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > MAX_CACHE_SIZE;
            }
        };  
    }  
```

初始化时设置最大容量。

LinkedHashMap传入第三个参数accessOrder为true，表示按照访问顺序排序，最新访问的会排序在前面。

同时LinkedHashMap存在方法removeEldestEntry，重写该方法。

当超出指定容量时，会删除排序在最后的元素，即被访问最少的元素，因为被访问后会重新排序，放在最前面。

## 五 redis集群模式

### 5.1 什么是哨兵模式

**概念**：使用哨兵工具（sentinel），哨兵为一个独立进程，哨兵通过与redis服务器进行通信，从而监控redis服务器是否正常运行。当哨兵监测到master出现问题，会自动将slave切换成master。

**哨兵作用**：

1. 集群监控，监控redis的master和slave是否正常工作
2. 消息通知，当redis出现故障，能够发送消息通知管理员
3. 故障转移，当master节点出现故障，能够切换到备节点
4. 配置中心，当节点出现故障，能够通知Client使用新的master节点

**缺点**：

1. 哨兵模式，只能有一个主节点对外提供服务，不能在线扩容，难以支持很高并发
2. 主节点容量设置过大，影响恢复和主从切换
3. 当主节点出现问题，主备切换时，这一瞬间，可能会造成不能访问，导致数据不一致问题

导致哨兵模式不再主流使用。该种方式也可以通过搭建多个主从方式解决。

![哨兵模式](.\img\02_05.PNG)

### 5.2 什么是redis高可用集群模式（Redis Cluster）

Redis Cluster是redis官方高可用集群方案

**特点**

由多个主从节点群组成的分布式服务器群，将每个节点设置成集群模式。

- 可扩展性，能够实现水平扩展
- 自动分割数据到不同的节点上，节点自身维护槽的映射关系
- 高可用，整个集群的部分节点失败或者不可达的情况下能够继续处理命令

![JedisCluster](.\img\02_06.PNG)

**数据分布原理** 

分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点 上，每个节点负责整体数据的一个子集。

redis3之后版本，**Redis Cluster，采用哈希分区规则**，采用虚拟槽分区。

![](.\img\02_03.jpg)

1. Redis Cluster 将所有数据划分为16384 的 slots(槽位)，每个节点负责其中一部分槽位，根据节点个数进行划分，默认等量划分
2. 当需要存储数据时，键值根据CRC16算法计算hash值，然后和槽位总个数16384 按位与，找到对应的槽位，每个节点负责维护一部分槽以及槽所映射的键值数据，因此，集群下redis节点存储数据不重复。
3. 当使用Java客户端Jedis时，客户端会缓存槽位配置信息至客户端本地，客户端要查找某个 key 时，可以直接定位到目标节点，然后直接去操作对应节点

**节点通信机制**

采用gossip协议维护集群元数据，所有节点都持有一份元数据，当元数据改变后，会将其发送到其它节点，让其它节点也进行更新。

gossip协议方式特点：所有节点元数据不是集中在一处管理，更新请求较慢，有时延。

集中式（如zookeeper）:元数据集中管理，更新读取时效性好。

**网络抖动**

真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。为解决这种问题，Redis Cluster提供了一种选项 cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。

**集群扩容**

gossip协议主要包含ping、pong、meet、fail类型消息等

节点之间会发送ping消息交换元数据信息，就能够知道哪些slot位于哪个节点上

在原有集群上扩容节点，主要通过redis集群提供命令完成，执行流程

1. 新增节点add-node 
2. 重新分片reshard，此时新加节点已经加入到集群中，并且是主节点(Master)，
3. 为新增节点配置从节点replicate

**请求重定向**

当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。

当使用Java客户端Jedis时，客户端会维护槽位配置表，能够通过计算hash，直接找到对应节点，如果没有获取到，会进行同步更新本地操作映射表。

**集群选举**

当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：

1. slave发现自己的master变为FAIL
2. 将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息
3. 其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack
4. 尝试failover的slave收集FAILOVER_AUTH_ACK
5. 超过半数后变成新Master
6. 广播Pong通知其他集群节点。

从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。

为了避免多个从节点投票相同，集群需要至少有3个主节点。

同时避免同时发起选举，还会有延迟计算公式：

```
DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms
```

SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举。但是，实际情况还会受网络等因素影响。

### 5.3 主从复制模式（Redis Replication）和高可用模式（Redis Cluster）如何选择？

**主从复制模式（Redis Replication）**，采用主从架构保证高并发，哨兵模式保证高可用。一主多从，单主用来写入数据，多从用来查询，读写分离，从的个数可以根据读的吞吐量来设置。然后再搭建哨兵集群，保证高可用。适用于需要缓存数据量较小，比如几个G。

**高可用模式（Redis Cluster）**：主要针对海量数据、高并发、高可用场景

## 六 redis如何保证高并发、高可用？

redis高并发：采用主从架构，一主多从，单主用来写入数据，多从用来查询，从的个数可以根据读的吞吐量来设置。

redis高可用：采用高可用集群模式，主要针对海量数据、高并发、高可用场景。

## 七 redis基础命令

### 7.1 scan命令

用于迭代当前数据库中的key集合，便于在大规模数据情况下，非阻塞快速查找符合某种规则的key，限制了返回元素个数，时间复杂度o(n)。相比于keys，返回所有符合条件的key，效率更高。

```
SCAN cursor [MATCH pattern] [COUNT count] The default COUNT value is 10.
```

cursor 游标： 记录迭代状态

MATCH：匹配指定格式的元素

COUNT：每次迭代中应该从数据集里返回多少元素

```
scan 0 MATCH * COUNT 2
1) "12"
2) 1) "mylist"
   2) "numn"
scan 0 MATCH * COUNT 5
1) "10"
2) 1) "mylist"
   2) "numn"
   3) "num"
   4) "set2"
   5) "list1"
   6) "kekexpire"
scan 10 MATCH * COUNT 5
1) "7"
2) 1) "key1"
   2) "scoreboard"
   3) "key2"
   4) "bar"
   5) "set1"
scan 7 MATCH * COUNT 5
1) "0"
2) 1) "username"
   2) "car"
   3) "key3"
```

该种方式是因为redis中key的存储是基于hash表，类似于HashMap那样数组+链表的结构。COUNT参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。直到返回0结束。

![key存储](.\img\02_04.png)



## 八 redis基本特性，事务、生成时间、排序、消息队列、管道

### 8.1 redis事务？

redis支持事务，操作都是原子性，是对数据的更改要么全部执行，要么全部不执行。但是redis事务不支持回滚。

例如对于运行时命令，1,2,3, 1执行完，2执行出错，3还是会执行，同时1,3的执行结果都会生效。

##### 命令MULTI、EXEC

包含在MULTI、EXEC间的命令执行完，才能返回各个命令执行结果

##### 命令WATCH

用于一个键或者多个键，一旦其中一个键被修改，之后事务将不再执行，直至执行到EXEC命令。

可以通过使用上述三个命令组合，实现事务操作。

### 8.2 生存时间？

```
// 设置键生存时间
EXPIRE key seconds
```

**应用**  **实现访问频率控制**

设置用户IP为key，1分钟，最大访问次数为100，超过100次提示报错，1分钟到，重新统计

**应用**  **实现缓存**

常使用信息，存入redis，设置生成时间1小时，若超过时间，需要重新读取数据。

同时可以设置参数，配置Redis最大可用内存，避免同时存在键过多，导致占用过大内存，从而制定规则来淘汰部分键。

### 8.3 排序

通过sort命令，能够对集合、列表、有序集合进行排序

通过by，指令某个参数进行排序。

sort时间复杂度O(n+mlogm)， n为列表元素个数，m为要返回元素个数

**提高性能使用原则：**

1. 尽可能减少排序键中元素个数，减小n
2. 使用limit只获取需要数据，减少m
3. 若排序数据量较大，使用store参数将结果缓存

排序底层实现采用**部分快速排序算法**

### 8.4 redis实现消息队列（任务队列）

RPOP命令，能够不断从键中取出元素

BRPOP命令，没有元素会阻塞，直到有元素加入

### 8.5 发布订阅

PUBLISH命令，发布者向指定频道发布消息

SUBSCRIBE命令，接收着从指定频道接收消息

### 8.6 管道

redis server和client通过TCP协议连接，消息来回自server端和client的耗时，称为往返时延。

可通过管道，一次性发送多条命令，在执行完成后一次性将结果返回，减少server和client端的通信次数，降低总体时延。
























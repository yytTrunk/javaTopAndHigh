[TOC]



### 一 JVM内存结构，Java内存模型，Java对象模型分别指什么

- **JVM内存结构**（也有叫作Java内存区域、Java内存结构等）

主要用来描述JVM内存管理机制中，JVM将内存主要分为：虚拟机栈、本地方法栈、堆、方法区和程序计数器。

- **Java内存模型**

主要用来描述程序中各个变量的访问规则，即在虚拟机中将变量（指实例字段、静态字段、构成数组对象的元素）存储到内存或从内存中取出的底层细节。

- **Java对象模型**

主要描述JVM中，对象如何创建、对象的内存布局（对象在内存中如何存放）、如何访问。



### 二 JVM内存结构？

#### 2.1 内存结构包含哪几块区域？

用来描述JVM内存管理机制，当一个类.class文件通过类加载机制加载进JVM内存中，它如何在内存中存放，哪些信息该放在哪个区域，在代码执行时如何获取的，JVM内存结构主要用来解决这个事情。主要包含以下几个区域

- 虚拟机栈

虚拟机栈表示的是Java类中方法执行时会在虚拟机栈中创建一个栈帧，压入虚拟机栈中，方法执行完后再出栈，每个方法都会对应一个栈帧，虚拟机栈线程私有。栈帧里用来存放方法中声明的局部变量表，操作数栈，动态链接和方法入口等信息。每个方法执行完，都会在虚拟机栈中有个进栈和出栈的过程。

![虚拟机栈描述](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_01.PNG)

**局部变量表**，容易理解，存放方法中局部变量，包含基本数据类型，对象的引用（局部变量也会有对象变量）等

**操作数栈**，程序运行时，操作数临时中转的区域，比如需要完成a=1的操作，会有操作iconst_1（将int型常量1压入操作数栈），istore_1（将int型常量压入局部变量表）这些操作数过程，操作数栈也对应着操作指令的进栈和出栈过程。

**动态链接**，在方法中还会调用其他方法，如何定位到其它方法所在位置，即通过动态链接。程序运行时，方法中再调用另一个方法，会先根据方法区的常量池中加载的类信息找到类对象头中的类型指针，找到对应方法内存地址，然后获取指令码执行，对应方法的内存地址就指动态链接。

**方法返回地址**，即返回方法被调用的地方。

- 本地方法栈

本地方法栈用来存放Native方法，Native方法可能调用的为由其他语言编写的动态链接库，通过JNI调用。

- 堆

在虚拟机栈的栈帧中的局部变量表中对于对象，放的是对象的引用，那实际的对象内容存放在哪个区域？堆中。

堆存放几乎所有实例对象，由垃圾回收器自动回收，所有线程共享。

- 方法区（以前也称作永久代，在Java8中称作元空间）

加载类后，方法中信息存放在虚拟机栈中，类中声明的变量，常量，这些信息放在哪里呢？方法区。

方法区用于存储被加载的类元信息（Klass，类的结构信息如类的版本、字段，有哪些方法等信息，在对象头中的类型指针Klass Pointer即指向该位置）、常量、静态变量、即时编译后代码等。

在Java8中，元空间使用的内存为直接内存，是物理内存，为JVM占用的内存以外的本地内存。

元空间带下，默认为20M

- 程序计数器

线程私有，用于记录当前线程代码（指字节码）执行位置。

#### 2.2 Java8对内存结构进行了哪些改进？

1. 移除永久代（Metaspace），改为元空间（Metaspace）
2. 将永久代中的常量和静态变量转移到堆中
3. 将永久代中的类元信息转移到元空间中
4. 元空间使用的内存为直接内存，是物理内存，为JVM占用的内存以外的本地内存

经过如此改进，类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，就不会遇到永久代存在时的内存溢出错误。但是带来问题是，必须监控内存消耗情况，一旦发生泄露，会占用大量本地内存。

#### 2.3 强引用、软引用、弱引用、虚引用指什么？(强软弱虚)

- 强引用

把一个对象赋给一个引用变量，这个引用变量就是一个强引用。 

垃圾回收，对于强引用的对象，即使出现了OOM，也不会对该进行回收

- 软引用

当系统充足时，不会被回收，内存不足时，会被回收。高速缓存。

通过SoftReference类实现

- 弱引用

弱引用关联对象，在下一次垃圾回收发生时，都会被回收

通过WeekReference类实现

应用：WeakHashMap，当触发GC，map中元素会被回收，应用于缓存

- 虚引用

对象持有虚引用，不会对对象的生存有任何影响，需要与引用队列一起使用。

虚引用的主要作用是跟踪对象被垃圾回收的状态 。

#### 2.4 深拷贝、浅拷贝分别指什么？

- 浅拷贝


拷贝后会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

- 深拷贝

拷贝后会创建一个新对象，并会拷贝对象中存在的引用对象的内存内容，不同于浅拷贝只是拷贝内存地址。深拷贝相比于浅拷贝速度较慢并且花销较大。

可通过实现序列化接口Serializable ，先将对象序列化，再反序列化，即可得到深拷贝对象s

- 注意规范

【推荐】慎用 Object 的 clone 方法来拷贝对象。
说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。

### 三 关于堆区的垃圾回收

堆存放几乎所有实例对象，由垃圾回收器自动回收，所有线程共享。

![堆的垃圾回收](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_02.PNG)

采用复制算法

堆中主要分为两个区域，新生代和老年代。新生代包含Eden区和两个Survivor区，新生代默认会占内存的1/3，老年代占2/3。当对象刚创建后存放在新生代的Eden区，当Eden区满后，会触发Young GC，对Eden区进行清除，没有被引用的对象直接回收，依然存活的对象会被移动到Survivor区，Survivor分为S0和S1两块区域。Survivor区在进行Young GC时也会进行清除，将Eden区移过来的，和正在使用的S0（假如在使用S0），复制到另一块未使用的空间S1，然后将当前正在使用的空间S0清除掉，然后切换S1为使用状态，此时Eden区和S0空间都被释放掉。如果Young GC回收的对象大于Survivor区，会直接进入老年代。是不是对象可以一直在S0或者S1进行交换？不是，每个对象都会有一个计数器（存放在对象的对象头中），每次触发Young GC都会加1，通过参数`-XX:MaxTenuringThreashold`参数能够配置计数器值，如果设置为1，那么触发一次Young GC就会进入老年代，该值默认配置为15。

如果老年代也无法放下，那么会触发Full GC，如果再放不下，则会抛出OOM。

通过visual GC插件，可以看到整个过程。

![visualGC](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_03.PNG)

### 四 类加载机制

#### 4.1 类加载过程？

主要分为三个阶段，加载、链接（验证、准备、解析），初始化。

- 加载，读取class文件的二进制流，生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据入口（就是说加载进来放在了方法区的一块地方，通过生成的对象，能够找到这个类的信息）
- 链接-验证，更详细的校验Class文件，字节流中的内容是否符合虚拟机要求
- 链接-准备，为静态变量（指静态变量）分配内存，并赋予该数据类型的零值（如`public static int value = 123`，赋予的值是0，而不是123）
- 链接-解析，解析类和方法，确保类与类之间相互引用正确
- 初始化，执行类构造器的<clinit>方法（包括类变量的赋值操作和静态语句块操作。）



#### 4.2 类加载器如何定位到具体的类文件并进行读取的？

**类加载器作用**：加载class文件

**类加载器分类**

- 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar、resources.jar等
- 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
- 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
- 用户自定义类加载器（User ClassLoader）,用户自定义类加载器

**加载类时使用双亲委派模型，过程如下**

- 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
- 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
- 加载不到则会报ClassNotFoundException

**例子**

比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？

不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。



#### 4.3 如何自定义类加载器？

可以通过继承ClassLoader类，重写findClass()方法，来自定义类加载器。

当父类加载失败，会调用自己的findClass()方法来完成加载。

通过自定义类加载器能够修改类加载的方法，隔离加载类等，从而避免类冲突。



#### 4.4 对象实例化过程

new对象时实际过程

- 确认类元信息是否存在。在元空间查看类元信息是否存在，若不存在，通过双亲委派模型，进行加载
- 分配对象内存。在堆中分配内存
- 设定默认值。设定成员变量初始化零值
- 设置对象头。设置新对象的对象头（包含哈希码、GC信息、锁信息、对象类元信息）
- 执行初始化方法。初始化成员变量，执行实例化代码块，调用类的构造方法，堆内对象首地址赋值给引用变量。



#### 4.5 为什么需要使用双亲委派模型

- 避免类重复加载，当父类加载器加载过后，子类不会重复加载
- 保证安全性，类加载器会去加载固定目录下，比如启动类加载器，加载jre/lib/目录下，这里类不会被随意窜改



#### 4.6 双亲委派模型如何实现？

双亲委派代码集中在java.lang.ClassLoader的loadClass()方法



#### 4.7 loadClass()   findClass()  defineClass()区别

- loadClass()，主要进行类加载方法，默认的双亲委派机制，在这里实现
- findClass()，根据名称或位置加载.class文件
- defineClass()，把字节码转化为Class



#### 4.7 如何破坏双亲委派模型？

双亲委派模型都是通过loadClass方法实现，想要破坏，可以通过自定义一个类加载器，重写其中loadClass方法，使其不进行双亲委派



#### 4.8 为什么需要破坏双亲委派？

1. JDNI、JDBC等需要加载SPI接口实现类

2. 实现热插拔部署工具

3. tomcat等web容器

   tomcat需要部署多个web应用，多个应用可能是同个应用不同的版本，同时部署时，进行加载，可能会存在加载已经加载过的类，此时按照双亲委派模型，不能再进行加载，无法加载多个相同的类。

   tomcat破坏双亲委派原则，提供隔离机制，为么给web容器单独提供一个webAppClassLoader加载器，可以加载本身目录下的class文件，加载不到时再交给CommonClassLoader加载。

4. OSGI等模块化技术

   加载器之间是不再是树状结构，而是网状结构。

   JDK9中的模块化，将rt.java tool.jar拆分为数十个模块，编译时只编译实际用到的模块。



#### 4.9 OGSI加载机制



### 五 垃圾回收机制

#### 5.1 垃圾回收的主要作用？垃圾回收的位置？

GC主要作用是清除不再使用的对象，自动释放内存。

垃圾回收主要是堆和方法区。



#### 5.2 GC如何判断哪些对象可以被回收？

**引用计数法**：给每个对象一个引用计数器，当被引用时计数器加1，引用失效时，计数器减1，当为0时，可以被回收。无法解决循环引用的问题，JVM未采用该种方式。

**可达性分析（即通过GC Roots）**：如果一个对象与GC Roots之间，没有直接或间接的引用关系，比如某个对象失去了任何引用，或者是两个对象循环引用等。



#### 5.3 哪些对象可以被选做GC Roots？

- 虚拟机栈的栈帧中的本地方法表中引用的对象（方法中声明的局部变量）

- 位于方法区中类静态属性中引用的对象（就是类中声明的静态变量用的对象）
- 方法区中常量引用的对象（常量）

- 本地方法栈中引用的对象（native方法）



#### 5.4 常见的GC算法有哪些？

包含标记-清除算法，标记-整理算法和复制算法。

- 标记-清除算法（适用于老年代）

触发GC后，从GC Roots出发，依次标记出被引用的对象，最后清除没有被标记的对象。

缺点：会造成大量空间碎片，当需要一块大的空间时，会容易触发Full GC。

- 标记-整理算法（适用于老年代）

从GC Roots出发，依次标记出存在引用关系的对象，将这些存活的对象整理到内存的另一端，形成内存连续空间，最后将另一部分清除掉，不会产生空间碎片。

缺点：需要额外的分配空间担保。

- 复制算法（主流的Young GC算法，作为新生代的垃圾回收）

将堆空间分为较大的Eden区和两块Survivor区，每次只使用Eden区和Survivor区中的一块。新对象创建时存储在Eden区，当Eden区满，执行YGC，将存活对象复制到Survivor区中一块（假设为S0），清空Eden区。当Eden区再满后，进行YGC，再标记出Eden区和S0中的存活对象，复制到另一块S1中，释放Eden区和S0区，使用S1区，如此循环。

**分配比例**：Eden区和Survivor区默认为8:1。新生代和老年代为1:2。

**优点**：避免了空间碎片问题。



#### 5.5 什么是stop the world?

垃圾回收时，需要停止用户的工作线程，只有GC线程工作，来标记出可以回收的垃圾对象，此过程称为STW（stop the world）。



#### 5.6 常用垃圾回收器有哪些？

**垃圾回收器是应用垃圾回收算法实现的内存管理模块**，主要四种Serial、Parallel、CMS、G1。

Java8默认采用并行多线程收集器，Parallel Scavenge (新生代，采用复制算法) 和 Parallel Old (老年代，采用标整理算法)

- **Serial（串行收集器）**

采用串行单线程方式完成GC任务，标记出可回收对象时，会暂停整个应用程序中工作线程进行垃圾回收（称为STW，stop the world），此时只要一个线程来完成GC任务。

特点：单线程，会暂停用户线程。不适合服务器端。

- **Parallel（并行垃圾收集器）**

Serial收集器的多线程版本，在STW时，有多个线程来完成GC任务。

特点：多线程，会暂停用户线程，适用于计算，数据处理等。

- **CMS（并发标记清除收集器，Concurrent Mark Sweep Collector）（配置参数 `-XX:UseConcMarkSweepGC` ）**

四个步骤，通过初始标记（标记与GC Roots直接相连的对象，单线程），并发标记（并发标记存活对象），重新标记，并发清除。

初始标记和重新标记也会引发STW，但时间较短。并发标记和并发清除，耗时较长，但能够与用户线程并发执行。

特点：CMS采用并发-标记算法，也会产生空间碎片，但低延时，能够快速响应，用于老年代。

与ParNew配合使用。

![](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_06.PNG)

PS：  [CMS在Java9中已被不推荐使用，后续将被移除](https://bugs.openjdk.java.net/browse/jdk-8229049)

- **G1**





#### 5.7 如何查看服务器默认的垃圾收集器？如何配置垃圾收集器？默认的垃圾回收器有哪些?

**查看默认垃圾收集器**：`-XX:+PrintCommandLineFlags -version`，查看JVM初始默认配置参数

**配置垃圾收集器**：通过配置参数  `-XX:UseSerialGC`     `-XX:UserParallelGC(Java8默认)`  `-XX:UseConcMarkSweepGC`  `-XX:UseG1GC`等配置

**默认垃圾回收器组合**：以下7种，连线表示新生代和老年代的垃圾回收器组合

![默认垃圾回收器组合](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_04.PNG)

**总结**：

![](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_05.PNG)

Java8中常用ParalleNew + CMS 

#### 5.8 G1垃圾回收器

**历程**：

![g1历程](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_07.PNG)

整体思想：化整为零，分而治之

**特点**：

- 把内存划分为多个独立，大小相同的子区域，包含Eden、Survivor（幸存区）、Old区和Hummongus。
- 分代收集，G1不再从物理上区分新生代和老年代（就是说一个区域可以在新生代和老年代变换），
- 整体上采用标记-整理算法，多个区块之间采用复制算法，都不会产生内存空间碎片
- 可预测的停顿，STW可控，用户可以指定期望停顿时间
- 用于替代CMS，Java9+默认GC

![G1区域划分](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_10.PNG)

**原理**：

- 将堆分成若干个大小相等的子区域，默认2048块（通过参数`-XX:G1HeapRegionSize=N`设置每块区域大小，范围在1MB-32MB，因此最大为32M*2048=64G），回收时不回收整个堆，选择一个区域集合Collection Set(CS)  
- 每个区可以表示为Eden、Survivor（幸存区）、Old区和Hummongus，Hummongus也为老年代区域，当分配到很大对象，直接放在该区域
- 对象的存储在物理内存上不要求一定是连续的，只要逻辑上连续即可，每个分区可以在新生代和老年代之间切换
- G1中包含两种GC，一种全部的YGC（Fully young GC） 和混合GC（Mixed GC）

**回收过程（4步）**：类似CMS

- 初始标记，标记出与GC Roots直接关联的对象
- 并发标记，从GC Roots开始，采用三色标记法，标记出存活对象（耗时较长，但能够与用户程序并发运行）
- 最终标记，修正并发标记期间，由于用户线程继续运行导致标记产生变化的那部分对象
- 筛选回收，根据期望时间制定回收计划

![](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_09.PNG)

**G1回收机制遇到的典型问题**：

- 老年代对象可能持有年轻代的引用（跨代引用）

- 不同region之间互相引用

![](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_11.PNG)

每个Region按照512个字节，分为若干个卡片，在每个Region中，都再对应一个Remembered Set，当卡片中存在引用时，会记录在对应Remembered Set中。因此在回收区域时，读取Remembered Set可以知道哪些卡片在引用我，只需要去扫描对应卡片的对象，避免了整个堆的扫描，提高了效率，典型空间换时间。

![](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_12.PNG)



#### 5.9 G1垃圾回收器与CMS对比，有什么区别？

- G1不会产生内存碎片，CMS采用标记-清除会存在碎片
- G1用户可以指定期望停顿时间



#### 5.10 GC调优步骤

1. 收集GC日志，运行时添加-`XX:+PrintGCDetails -XX:+PrintGCTimeSTamps -XX:+PrintGCDateStamps -Xloggc:./gc.log`

2. 分析日志得到关键性能指标
3. 分析GC原因，调优JVM参数



#### 5.11 什么时候触发Young GC？如何触发Full GC？

对象创建时，会存放在新生代Eden区

大对象会直接进入老年代

长期存活的对象（触发一次YGC，会+1，默认15次）将进入老年代

- YGC，当新生代Eden区满了后会触发Young GC，新生代对象存生存期短，发生GC频率高
- Full GC，老年代满了后，会触发Full GC（也会是要往老年代放对象，放不下的时候），在Full GC前触发一次YGC，能够加快老年代的回收对象



#### 5.12 JVM常用的配置参数有哪些？（或者是你用过哪些JVM配置参数？）

常用以下常用参数即可

`-Xms`  等价于 `-XX:InitialHeapSize=`    设置初始堆内存，默认为1/64

`-Xmx`  等价于  `-XX:MaxHeapSize=`   最大堆内存 ，默认为物理内存的1/4

`-Xss`  等价于 `-XX:ThreadStackSize=`  设置单个线程栈大小，通常默认为512k-1024k，依赖于平台

`-XX:NewSize=256m  -XX:MaxNewSize=256m`  设置新生代大小

`-XX:MetaspaceSize=128m`  设置元空间大小，元空间与永久代类似，Java8后成为元空间，元空间内存使用本地内存，因此元空间本地大小也依赖于本地内存大小，也可通过此参数设置

`-XX:+PrintGCDetails`     打印GC详细信息



以下为补充

（JVM参数类型主要分为标配参数、X参数和XX参数。主要需要知道XX参数。）

Jvm参数主要是以XX开头

- boolean型   `-XX:+或者-`，+表示在使用，-表示关闭

`-XX:+PrintGCDetails` 打印GC信息

- key/value型 设置类型，设置具体值，-XX:属性key=属性值value

`-XX:MetaspaceSize=128m`  设置元空间大小

`-XX:MaxTenuringThreashold=15`   设置年轻代进入老年代，进行YGC个数

`-Xms`  等价于 `-XX:InitialHeapSize=`    设置初始堆内存

`-Xmx`  等价于  `-XX:MaxHeapSize=`   最大堆内存  



- 查看JVM默认参数值

方法1

通过jps查看Java的进程号，再通过`jinfo -flag Metaspacesize 27008`，能够查看该参数配置情况

方法2

`java -XX:+PrintFlagsInitial`   直接查看所有初始参数

`java -XX:+PrintFlagsFinal`    可以查看JVM修改过的参数，用了`:=`标出

`java -XX:+PrintCommandLineFlags`    打印JVM默认采用的优化参数



#### 5.13 如何查看GC日志

- Young GC

![GCri值](https://gitee.com/codeyyt/my_pic/raw/master/image-blog/javath/03/02_13.PNG)



### 六 JVM性能优化

#### 6.1 JVM常用性能监控工具，怎么用？

- 虚拟机Java进程监视工具（jps），

- Java配置信息工具（jinfo），

- 内存映像工具（jmap）,

- 统计信息监视工具（jstat）,能够实时对Java程序运行情况进行监视

  ```java
  >jstat -gcutil -h3 19200 1000
    S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
   95.62   0.00  75.39  88.32  68.93  77.04    154   15.233     4    0.333   15.566
   95.62   0.00  75.39  88.32  68.93  77.04    154   15.233     4    0.333   15.566
      
  -class 显示ClassLoad的相关信息；
  -compiler 显示JIT编译的相关信息；
  -gc 显示和gc相关的堆信息；
  -gccapacity 　　 显示各个代的容量以及使用情况；
  -gcmetacapacity 显示metaspace的大小
  -gcnew 显示新生代信息；
  -gcnewcapacity 显示新生代大小和使用情况；
  -gcold 显示老年代和永久代的信息；
  -gcoldcapacity 显示老年代的大小；
  -gcutil　　 显示垃圾收集信息；
  -gccause 显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；
  -printcompilation 输出JIT编译的方法信息
  ```

  

- 堆栈异常跟踪工具（jstack），

- jvisualvm

- jconsole



#### 6.2 服务器变慢，可通过哪些命令分析？

- 查看整机系统性能：top 命令，看cpu、内存使用率，系统平均负载（load average，）
- 查看CPU：vmstat命令、pidstat命令
- 查看内存：free
- 查看硬盘：df
- 查看磁盘IO：iostat
- 查看网络IO：ifstat



#### 6.3 系统CPU使用率过高，定位分析思路？

能结合Linux和JDK命令一起分析，定位出是哪个线程，哪行代码出现问题

# 面经



# 截至2021-02-03



## Java基础

1. hashmap里的hash函数你自己的话如何实现，如果你的hash函数总是取模后在固定的几个位置，如何优化这种情况

   > Java8针对hashcode计算方法已经进行了优化，会将hashcode值右移16位，然后再与自身进行按位与操作，计算存储位置时为(n-1)&hashcode的方式，此时hashcoded的32位都参与了运算，避免了在容量较小时，hashcoded的高位无法参与计算。

2. HashMap初始化10000，如何扩容

3. hashmap如何get一个元素

4. hashmap底层查找的时间复杂度

5. 谈谈对多态的理解

6. 面向对象的特性

   > 前提是抽象
   >
   > 封装 ：继承 多态
   >
   > 继承：层次化结构，类继承、接口继承
   >
   > 多态：实现多态两种方式：
   >
   > 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
   >
   > 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
   >
   > 多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作，
   >
   > 封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）

7. 面向对象的设计原则

   > 单一职责原则：一个类应该仅有一个引起它变化的原因
   >
   > 开放封闭原则：对扩展是开放的，对更改是封闭的
   >
   > 里氏替换原则：子类可以替换父类并且出现在父类能够出现的任何地方
   >
   > （父类应尽可能使用接口或者抽象类来实现，子类通过实现了父类接口，能够替父类的使用地方）
   >
   > 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象，面向接口编程
   >
   > ISP 接口隔离原则：使用多个专门的接口比使用单个接口要好的多

8. 什么时候需要重写父类的方法

9. arraylist和linkedlist的区别

   > 底层实现不同：数组，双向链表
   >
   > 特点不同：数组，内存连续；链表不连续，内存利用率高
   >
   > 数组指定位置插入、删除元素较慢，需要拷贝元素至新的数组中
   >
   > 应用场景不同：arraylist 查询快
   >
   > linkedlist：插入、删除快，查询慢
   >
   > 都不是线程安全
   >
   > 
   >
   > ArrayList动态扩容
   >
   > 初始化时可以设定数组大小，未设置默认为0；第一次添加元素，默认设置容量为10。
   >
   > - 在每次添加元素的时候，都会先调用ensureExplicitCapacity()方法，去判断elementData中容量，当容量不够时，调用grow()方法，去增大容量，首先通过 oldCapacity + (oldCapacity >> 1) 增大为elementData中原有容量的1.5倍，若容量仍然不够，则直接扩充至请求的容量。这样可以保证elementData每次都接近实际size的大小。
   >
   > - 扩容后，会调用 Arrays.copyOf()方法，将元素移动至新的数组中，所以每次使用ArrayList添加元素时，如果每次都需要扩容将会慢一些；同时在remove()时，也会去移动元素。Arrays.copyOf()实现是调用System.arraycopy()方法。

10. HashMap为什么长度是2的n次幂，数据结构，扩容（包括元素移动的细节），线程不安全的问题

12. CopyOnWriteList怎么保证线程安全，为什么这么做？

13. list和set的区别？以及各个实现类和底层实现

14. B+树与B树有什么区别？

15. 讲一下B+树的实现

15. 了解什么叫不可变类么？或者是叫不可变对象？

    > 不可变类（Immutable Objects）：当类的实例一经创建，其内容便不可改变，即无法修改其成员变量。
    >
    > 可变类（Mutable Objects）：类的实例创建后，可以修改其内容。
    >
    > Java 中八个基本类型的包装类和 String 类都属于不可变类，而其他的大多数类都属于可变类。

16. final的含义是什么？

    > final 修饰的字段初始化后是不可变的，而这种不可变就是指引用的不可变。具体就是该引用所指对象的内存地址是不可变的，但并非该对象不可变。

17. 成员变量都是final修饰的话，如何进行赋值？

    > final修饰变量必须在初始化的时候进行赋值，否则编译会报错
    >
    > 直接赋值
    >
    > 构造方法中赋值

18.  HashMap 在扩容时, 对读写操作有什么特殊处理？

19. 为什么是6，变为链表

    > 中间有个差值7可以防止链表和树之间频繁的转换

20. hashmap的tableSizeFor方法

21. 1.8相比1.7为什么头插变尾插？





## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS

   > AQS为抽象队列同步器，构建锁底层框架

8. volatile关键字的作用，原理



9. synchronized

   > 锁升级
   >
   > 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁



10. threadPoolExcutor构造函数的各个参数详解

    > - corePoolSize：  核心线程数量，即使空闲，也不会终止（类似于今日某银行网点的值班窗口）
    > - maximumPoolSize： 最大线程数，线程池里能够容纳同时执行的最大线程数量，值必须大于1。（银行网点最多有这么个窗口，大于corePoolSize的可理解为今日可加班的窗口）
    > - workQueue： 任务队列，用于保存等待执行任务的阻塞队列，只包含有execute方法提交的Runnable。（类似于银行网点的候客区）
    > - keepAliveTime：空闲线程最大等待时间，当存在线程数大于核心线程数量，多余线程会在等待keepAliveTime长后销毁，直至线程数等于corePoolSize。（当人数变少了，加班窗口等待keepAliveTime时间后，没有客户，可以关闭）
    > - threadFactory：设置生成线程池中工作线程的线程工厂，可通过工厂为线程设置独特名称，一般默认。
    > - handler：线程池拒绝策略，当队列满了且工作线程数大于等于线程池中的最大线程数（maximumPoolSize），对新提交任务的处理策略。默认为AbortPolicy，抛出RejectedExecutionException异常。（银行窗口都满了，候客区也满了，其余再来人员就要拒绝）
    >
    > 流程，当corePoolSize满了，先去阻塞队列排队，阻塞队列满了，还能去启动（maximumPoolSize-corePoolSize）个线程，当都满了，再执行拒绝策略。

11. Java并发 future怎么使用 waitqueue

12. concurrenthashmap

    > ##### 介绍ConcurrentHashMap
    >
    > 线程安全的HashMap，基本结构一样。
    >
    > 相比于Java7，Java8中有了较大改变
    >
    > - ConcurrentHashMap，key和value均不能为null，会抛空指针异常，HashMap中当key值为null，设定hash为null
    >
    > - Java7中采用分段锁，将整个大数组划分为多个小段，每个小段对应一个锁，进行分段加锁；Java8中，进行了锁粒度的细化，锁为每个数组中元素，采用了 CAS + Synchronized来保证并发安全性。
    >
    >   
    >
    > ##### 2.2 put方法流程？
    >
    > - 若第一次table为null，先初始化一个默认容量为16的数组table。若不为null，根据(n - 1) & hash计算数组下标，若table[i]不存在元素为null时，不需要加锁，直接通过CAS写入元素，同时刻只有一个线程能够写入成功
    > - 若table[i]存在元素，根据table[i]的hash值判断是否正在扩容，若在扩容，协助扩容
    > - 若不在扩容，使用Synchronized同步，锁为table[i]元素，根据table[i]判断是进行链表还是树方式进行节点插入（因为转化为树后节点hash值为负数）。（锁的选择进行了优化）
    > - 插入完成后，如果链表节点数为8个，将链表转化为红黑树
    >
    > 因此，如果多个线程对同一个位置元素进行处理，才会使用Synchronized加锁，否则是可以多线程同时操作。
    >
    > 
    >
    > ##### 2.3 get方法流程？
    >
    > 读元素不需要加锁
    >
    > - 根据key计算hash值，找到数组位置table[i]
    > - 如果table[i]就为目标值，直接返回
    > - 若为红黑树，按照红黑树方式遍历
    > - 若为链表，按照链表方式

13. threadlocal原理

    > 作用
    >
    > ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，
    >
    > 在多线程环境下，能够防止自己的变量被其它线程篡改。
    >
    > 往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。
    >
    > 原理
    >
    > Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象
    >
    > 每个Thread维护着一个ThreadLocalMap的引用
    >
    > ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储
    >
    > 调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象
    >
    > （ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置，然后比较key）
    >
    > 调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象
    >
    > ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。
    >
    > 场景
    >
    > [ThreadLocal解决SimpleDateFormat多线程安全问题](https://blog.csdn.net/Android_Mrchen/article/details/84580474)
    >
    > 参数传递

14. syn和lock的区别，哪个更好？怎么选择？

    > 都是用来保证线程安全
    >
    > 使用上区别：
    >
    > syn关键字，JVM层面，lock为API层面
    >
    > syn不需要手动去释放锁，lock需要
    >
    > syn为可重入，非公平锁，lock可以公平可以非公平
    >
    > syn可以绑定多个条件

15. 锁粗化、锁消除

    > 锁消除
    >
    > 编译时，JIT通过逃逸分析技术，分析synchronized锁对象，如果synchronized修饰的同步代码块，不存在竞争，只有一个线程进行加锁访问，则会将monitorEnter、monitorExit去掉，去除锁，不需要加锁。
    >
    > 锁粗化
    >
    > 存在连续多个synchronized同步代码块进行加锁，释放锁，可以将其进行合并为一个，进行放大粗化，避免多个加锁释放锁。
    >
    > JIT逃逸分析
    >
    > [深入理解Java中的逃逸分析](https://blog.csdn.net/hollis_chuang/article/details/80922794)

16. 线程的状态，以及变化的时机

    > 五种状态
    >
    > 新建状态：new了之后，还未启动
    >
    > 运行（Runnable）：线程可能正在运行或者可能正在等待CPU时间片轮转到
    >
    > 等待状态（WAITING）:无限期等待，等待被其它线程唤醒
    >
    > 超时等待状态（TIMED_WAITING）：超时等待状态，若超时时间到，会由系统自动唤醒
    >
    > 阻塞状态（BLOCKED）：正在等待获取一个锁，不同于等待状态，等待状态是等待一段时间或者等待其它线程唤醒。程序等待进入同步区域时，会进入该种状态。
    >
    > 结束（Terminated）:终止状态，线程已经结束。
    >

17. synchronized修饰同一个类的两个静态方法同步吗，为什么？

    > 同步，锁对象一样，都为类对象

18. 线程池设置了coreSize和maxSize之后，如果线程数量已经达到了coreSize，这个时候进来一个任务，会怎么处理？

    > 

19. 跟线程相关的方法介绍一下

    > yield，暂停当前正在执行的线程对象，并执行其他线程，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果
    >
    > join，join()方法的作用是调用join()方法的线程等待该线程完成后，才能继续运行main线程等到其他多个线程执行完毕后再继续执行。其他多个线程之间并不需要互相等待。父线程等待子线程结束之后才能继续运行
    >
    > sleep，睡眠，但是不释放锁
    >
    > interrupt，

20. retryLock了解吗？

21. Java里的轻量级锁？

    > CAS
    >
    > https://blog.csdn.net/lengxiao1993/article/details/81568130

22. 如何关闭线程？

    > Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。
    >
    > 只是改变中断状态，不会中断一个正在运行的线程。
    >
    > 当对一个线程，调用 interrupt() 时，
    > 1.如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。
    >
    > 2.如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。

23. 假如我还想隔离两个线程的数据, 怎么办？

    > Threadlocal

24. 本地线程和守护线程的区别，Thread.setDemon();
25. Threadlocal不remove掉会有什么问题？















## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

3. 类加载过程

   > 使用到双亲委派模型
   >
   > 加载
   >
   > 验证
   >
   > 准备
   >
   > 解析
   >
   > 初始化

4. G1垃圾收集器

5. 标记清除的过程，标记清除算法如何给对象分配内存空间？

   > 标记清除先根据GC Roots找到存活对象，将其它不存活对象清除掉
   >
   > 适用于老年代，会造成大量空间碎片

6. cms算法的缺点

   > 并发标记清除，老年代
   >
   > 垃圾回收线程并发
   >
   > 四个步骤：
   >
   > 初始标记，根据GCRoots直接找到与之直接相关联的，单线程（STW）
   >
   > 并发标记，并发标记相连的
   >
   > 重新标记，多线程标记（STW）
   >
   > 并发清除，
   >
   > 
   >
   > 特点：CMS采用并发-标记算法，也会产生空间碎片，但低延时，能够快速响应，用于老年代。

7. java的虚引用是什么用的

   > 用于跟踪垃圾回收
   
8. 哪个区域不会发生内存溢出？

   > 
   >
   > 

9. 自己写的 Java 应用调优过哪些 JVM 参数, 为什么这么调优?

10. 



## Spring

1. 讲讲spring boot启动流程
2. spring启动流程
3. spring bean生命周期
4. bean实例化过程
5. Spring MVC，说一下请求处理流程
6. Spring循环依赖有几种，如何解决
7. spring AOP
8. SpringBoot的特点
9. Spring IOC，AOP你的理解讲一下？
10. Spring注入方式知道哪些？
11. bean是线程安全的吗？







## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 微服务中服务注册中心的具体实现，为了防止服务注册中心集群挂掉或者要扩容应该怎么去配置和部署

5. dubbo原理，dubbo往zk写入的内容是什么

6. dubbo客户端负载均衡如何实现的，给你你如何实现，一步步提示和完善

7. fegin了解吗，手写过源码吗？

8. Dubbo服务暴露过程

9. Dubbo的spi和jdk的什么区别

10. Rabbitmq和kafka区别

11. Kafka适合什么场景，项目中是什么场景

12. Rabbit如何保证消息不丢失

13. Zk满足了CAP哪些特性

14. redis和zk分布式锁设计，使用注意事项

15. 分布式如何保证一致性

16. 负载均衡算法实现

17. 轮询和随机的缺点

18. 如果redis作为分布式锁的时候，主节点挂掉了，但是数据还没有同步到从节点，这种情况怎么办

19. 加锁的时候什么时候选择本地锁，什么时候选择分布式锁？

20. RabbitMQ优缺点讲一下？

21. cap理论

22. rocketmq的消费模式

23. MQ用在业务场景？MQ本身的优势是什么？一般什么情况下可以使用这个技术？核心本质原因是什么呢？开线程做不就可以了区别是什么？







## Netty

1. NIO 异步这些了解过吗 能不能说一下
2. netty线程模型
3. 怎么解决粘包问题
4. nio bio区别，nio底层epoll实现



## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现

   > 底层实现没有采用C语言的字符串类型
   >
   > 定义了新的数据结构，SDS即*Simple Dynamic String* ，是一种动态字符串
   >
   > ```c
   > struct sdshdr{
   > int len;/*字符串长度*/
   > int free;/*未使用的字节长度*/
   > char buf[];/*保存字符串的字节数组*/
   > }
   > ```
   >
   > 
   >
   > - C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。
   > - 避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。
   > - 空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。
   > - 惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。
   > - 二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用'\0'标识字符串的结束，如果我们存储的字符串中间出现'\0'，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。
   >
   >  字符串最大为512M

2. redis分布式锁的底层lua setnx

   > 

3. Redis有哪5种数据类型，底层实现结构

   > String
   >
   > Map     
   >
   > List
   >
   > Set
   >
   > Sorted Set

4. Set、Zset分别用于哪些场景

   > Set 为无序集合、自动去重，可用于存储类似文章标签。Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能
   >
   > zset为有序集合，去重，用于排行榜，按点击率排名

5. Redis是怎么删除过期key的

   > 由于Redis是将数据存储在内存中，容量有限，需要尽可能存储热点数据
   >
   > 两种方式
   >
   > 定期删除，定时100ms，随机抽取设置了过期时间的key，删除已经过期了的数据
   >
   > 惰性删除，当请求指定key的数据，会先判断是否设置了过期时间，是否超时，如果数据已过期，将不会返回
   >
   > 采用两种方式结合
   >
   > 
   >
   > 同时，redis还有缓存淘汰策略
   >
   > 

6. Redis有哪些持久化方式

   > 有两种
   >
   > RDB  执行过命令后，会将内存中存储的数据定时存储到硬盘上，存储在dump.rdb文件中，通过定时N秒内有M个操作的方式触发存储，该种方式容易造成数据丢失
   >
   > AOF  命令执行过后，会将命令记录到文件中，恢复时，直接将执行过命令重新执行一次，即可恢复，当存储命令较多，重启时Redis启动较慢
   >
   > 两种方式各有优势
   >
   > Redis4.0 混合持久化，两种方式结合

7. Redis常用的应用场景

   > 1）利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力
   >
   > 2）利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码
   >
   > 3）利用setnx命令的特性，可以实现分布式锁

8. Redis缓存穿透是什么，如何解决？

   > 缓存穿透，是有大量缓存、数据库中不存在的请求，请求直接打到数据库上
   >
   > 解决方案
   >
   > 1. 加校验，对明显有误的请求参数，不下发处理
   > 2. 当请求不存在数据，返回时，同步到redis中，设置null值，并设置过期时间（时间不能过长）
   > 3. 使用布隆过滤器

9. Redis缓存雪崩

   > Redis能够抗住每秒1w请求，但是同时有20w访问量，导致Redis扛不住
   >
   > 解决方案
   >
   > 1. 增加多级缓存，本地缓存，先判断本地缓存是否存在，
   > 2. 使用Redis高可用集群模式，保证高可用，使用RDB+AOF持久化，保证挂掉后可以快速恢复
   > 3. 限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。

10. Redis击穿

    > 缓存击穿，热点数据大量同时失效，同时大量用户访问，请求全部打到数据库
    >
    > 解决方案
    >
    > 1. 设置热点数据永不过期，通过定时任务去定时更新
    > 2. 采用分布式锁，热点数据失效，为了避免同时大量请求直接都去查询数据库，此时需要加锁，查询一次数据库后，更新至缓存，其它在等待锁的请求，进来后先再查询一遍缓存，此时缓存里已存在，可以直接返回，不必查询数据库。

11. Redis分布式锁

12. 项目中缓存使用场景，双写一致性怎么保证的

    > **情景1**： 先更新数据库，然后再去删除缓存，但是删除缓存失败，导致两者数据不一致
    >
    > **解决** 先删除缓存，再去更新数据库。如果更新数据库失败，缓存中为空，不会造成数据不一致
    >
    > **情景2**：读写并发情况下对同一数据进行读写，更新数据时，先把缓存删除了，但是在更新数据库期间，还未完成，有请求过来，先请求缓存为空，然后去请求数据库，读取到旧值，又把旧值更新到了缓存中，会导致数据不一致
    >
    > **解决** 针对修改同一个数据请求操作，进行hash，划分到一个队列中，一个队列对应一个线程。同时，读取数据时，发现数据不在缓存中，也可将重新读取数据和更新缓存操作，发送到同一个队列中，此时一个线程处理该队列中操作，串行化执行。

13. redis zset实现，跳跃表实现 时间复杂度

14. 跳跃表的思想时怎样的？哪里有用到跳跃表

15. redis长度过长怎么优化？哪个api，数据量超过多少效率会变低？

16. redis使用过程中出现过变慢的情况吗？

17. 

    



## 数据库MySQL

1. mysql的索引，innodb的行锁的理解

2. mysql索引==== B+ 日志问题（3个）

3. innodb和myisam区别

4. 如果由大量的增删操作，那么应该选择哪个存储引擎，为什么

5. myisam和innodb支持锁的粒度是怎样的

6. 索引都要怎么设计才能达到最优

7. mysql连接池满怎么排查

8. 间隙锁如何实现，幻读问题是什么，它是怎么通过间隙锁解决的，for update能否锁表

9. 分库分表怎么设计

10. 水平分表依据什么分？时间还是数据

11. 分库分表之后我想查询近期的订单，怎么查

12. select count(*)时InnoDB和MylSAM分别是怎么处理的

13. 聚簇索引和非聚簇索引的区别

14. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？

15. 事务有哪些隔离级别，分别解决了什么问题

16. 可重复读是怎么解决脏读的

17. 有俩事务，事务A：读、写(张三)、读  事务B：读、写(李四)、读，假如俩事务同时执行，结果如何

18. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？

19. 有一个表存在字段id（非主键、递增可重复）、name，如果有1000W条数据，查其中一条，有索引和没索引的情况下执行时间，建索引是否有用、会走索引吗、为什么

20. 说说MySQL索引为什么用B+树呢，b树，红黑树呢？为什么不用

21. MySql调优

    > **数据选型：**首先是数据选型方面进行优化，选取最适用的字段属性，数据的表越小，查询越快 
    >
    > **范式应用：**合理使用范式和反范式 
    >
    > **存储引擎的选择：**如果该数据库读操作较多，存储引擎选择MyISAM，如果是写操作多，选择innodb 
    >
    > **主键选择：**代理主键 
    >
    > **执行计划explain：**使用explain+sql测试sql语句执行情况，然后优化sql语句 
    >
    > 1.  注意的关键字：type关键字，通常达到range级别，最好是ref，而ref最好是一个常数。 
    >
    >  **索引优化：** 
    >
    > 1.  尽量在主键上添加使用索引 
    > 2.  利用覆盖索引、索引下推机制，注意组合索引的匹配原则， 
    > 3.  尽量使用唯一索引，避免使用普通索引 
    >
    > **查询优化：**这个应该被包含在执行计划中，但是个人觉得还是拆出来，其实我们在写的时候就该注意sql的效率，explain执行计划只是验证 
    >
    > 1.  优化数据访问，避免查询中出现筛选大量数据，可以通过limit限制； 
    > 2.  避免select * from table这种全表扫描的语句 
    > 3.  如果业务没有特殊规定数据，那么就尽量避免使用UNION，可以考虑UNION-ALL替换，因为后者不会过滤重复数据，效率高于UNION

22. 索引失效场景有哪些

23. mysql 幻读和间隙锁 分片实现事务，mysql原生实现分布式事务

24. 分库分表是以什么维度来划分的？划分的算法是怎样的，会不会出现数据分配不均衡的情况。

25. 事务的ACID，每一项是如何保证的

26. SQL查询优化怎么做

27. 4种事务隔离级别和分别的问题？

28. MySQL 如何分析一条语句的执行过程。delete from t1 limit 3和delete from t1的区别？





## 网络

1. http四次挥手--报文传递参数是什么
2. HTTPS工作原理
3. TCP的三次握手四次挥手、滑动窗口
4. TCP/IP四层协议、ip在哪层
5. TCP有无状态
6. 输入url到页面加载完中间的流程
7. 线上用户出现502错误你怎么排查
8. 为什么连接的时候是三次握手，关闭的时候却是四次握手
9. tcp四次挥手过程？为什么等待2MSL
10. http常见状态码
11. TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些
12. TCP三次握手过程以及每次握手后的状态改变，为什么三次？ 为什么两次不行？
13. 301和302有什么区别
14. 504和500有什么区别
15. HTTPS 和 HTTP 有什么区别
16. http 1.0 1.1区别？





## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。

2. 设计一个缓存，在springboot启动时就加载好，你会怎么设计，把相应要用到的注解和类方法都描述一下

3. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发

4. Redis也扛不住了，万级流量会打到DB上，该怎么处理

5. 并发量很大，服务器宕机。你会怎么做

6. 一个url对应一个random值，要求设计一个系统，根据url查询random值，具体到表怎么设计，索引怎么加，代码怎么写？

7. 我有8件事要做，最要要同意返回处理结果，每件事要进行异步的方式去做。你怎么完成这个需求





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）
2. LRU实现，从O(n)到O(1)的各种方案，最理想的情况是什么
3. 最小覆盖子串
4. 如何判断一个链表是环链
5. 二叉树遍历，递归，非递归，层次遍历
6. 判断图中形成环 优先队列的删除节点方式
7. 两个数组如何找交集
8. 输入一行字符串
   找到里面最大的那个在后面加上(max)
   如果有多个就在每个后面都加上
   最后输出
   两次循环一次找最大
   第二次在每个最大后面加max
9. 最长回文串
10. 一个无序数组，求topk
11. 排序算法你知道那些？快速排序平均时间复杂度和最差时间复杂度。partition过程中最差情况是什么样的，描述一下

12.二分查找

13. 反转链表
14. 删除二叉搜索树的某一个节点
15. 给定数组，求第k大的数字
16. 求递增数组中相加等于10的元素对
17. 数组从下标最大的删与最小的删有什么区别
18. 合并两个有序的数组
19. 最长只有一种字符的字符串
20. [2个栈实现队列](https://www.nowcoder.com/jump/super-jump/practice?questionId=23281)
21. [合并有序链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=682)
22. [是否回文链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008769)
23. 快排
24. M*N 横向纵向均递增的矩阵找指定数
25. [两个排序数组找中位数](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008512)
26. [跳台阶](https://www.nowcoder.com/jump/super-jump/practice?questionId=23261)





需要过的题目

https://www.nowcoder.com/discuss/594301



## 设计模式

1. 单例模式
2. 策略模式
3. 装饰器模式
4. 适配器模式
5. 工厂模式



## Linux

1. 查看 CPU 的命令和磁盘 IO 的命令





## 其它

1. 你有遇到什么样的技术难题？
2. 有了解过领域模型相关知识？
3. 项目中最大的亮点，或者说项目中最大的难题是怎么解决的？

4. 日志大数据处理桶排序





## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)

[发个已经跪了的阿里一面，大概40分钟左右](https://www.nowcoder.com/discuss/593710)

[字节跳动1年半经验（双非非科班）一面面经](https://www.nowcoder.com/discuss/593554)

[顺丰后端社招面经](https://www.nowcoder.com/discuss/experience?tagId=639&order=3&companyId=0&phaseId=3)

[北京天润融通科技Java社招面经](https://www.nowcoder.com/discuss/591855)

[sap 上海 java 社招](https://www.nowcoder.com/discuss/588635)

[秋招社招经验(2020.12)](https://www.nowcoder.com/discuss/585741)

[携程社招Java二面面经](https://www.nowcoder.com/discuss/584725)

[社招-携程Java初面面经](https://www.nowcoder.com/discuss/584451)

[腾讯Java工程师社招面试经历](https://www.nowcoder.com/discuss/583626)

[腾讯Java社招面试经历记录](https://www.nowcoder.com/discuss/583601)

[小米社招Java岗一二面](https://www.nowcoder.com/discuss/583517?source_id=discuss_experience_nctrack&channel=-1)

[京东Java社招面试经历分享](https://www.nowcoder.com/discuss/583437?source_id=discuss_experience_nctrack&channel=-1)

[oppo社招Java面试经历分享](https://www.nowcoder.com/discuss/581405?source_id=discuss_experience_nctrack&channel=-1)

[字节跳动后端社招面试分享](https://www.nowcoder.com/discuss/578918?source_id=discuss_experience_nctrack&channel=-1)

[PingCAP后端社招面试经历](https://www.nowcoder.com/discuss/578850?source_id=discuss_experience_nctrack&channel=-1)

[1.3年工作经验，双非裸辞社招面经](https://www.nowcoder.com/discuss/578614?source_id=discuss_experience_nctrack&channel=-1)

[腾讯Java社招面经分享](https://www.nowcoder.com/discuss/578277?source_id=discuss_experience_nctrack&channel=-1)
# 面经



# 截至2021-02-03





## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS以及volatile，还有synchronized

8. 





## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

   



## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 



## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现
2. redis分布式锁的底层lua setnx







## 数据库MySQL

1. mysql的索引，innodb的行锁的理解
2. mysql索引==== B+ 日志问题（3个）







## 网络

1. http四次挥手--报文传递参数是什么





## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）





需要过的题目

https://www.nowcoder.com/discuss/594301







## 其它

1. 你有遇到什么样的技术难题？
2. 







## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)


# 面经



# 截至2021-02-03



## Java基础

1. hashmap里的hash函数你自己的话如何实现，如果你的hash函数总是取模后在固定的几个位置，如何优化这种情况

   > Java8针对hashcode计算方法已经进行了优化，会将hashcode值右移16位，然后再与自身进行按位与操作，计算存储位置时为(n-1)&hashcode的方式，此时hashcoded的32位都参与了运算，避免了在容量较小时，hashcoded的高位无法参与计算。

2. HashMap初始化10000，如何扩容

3. hashmap如何get一个元素

4. hashmap底层查找的时间复杂度

5. 谈谈对多态的理解

6. 面向对象的特性

   > 前提是抽象
   >
   > 封装 ：继承 多态
   >
   > 继承：层次化结构，类继承、接口继承
   >
   > 多态：实现多态两种方式：
   >
   > 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
   >
   > 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
   >
   > 多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作，
   >
   > 封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）

7. 面向对象的设计原则

   > 单一职责原则：一个类应该仅有一个引起它变化的原因
   >
   > 开放封闭原则：对扩展是开放的，对更改是封闭的
   >
   > 里氏替换原则：子类可以替换父类并且出现在父类能够出现的任何地方
   >
   > （父类应尽可能使用接口或者抽象类来实现，子类通过实现了父类接口，能够替父类的使用地方）
   >
   > 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象，面向接口编程
   >
   > ISP 接口隔离原则：使用多个专门的接口比使用单个接口要好的多

8. 什么时候需要重写父类的方法

9. arraylist和linkedlist的区别

   > 底层实现不同：数组，双向链表
   >
   > 特点不同：数组，内存连续；链表不连续，内存利用率高
   >
   > 数组指定位置插入、删除元素较慢，需要拷贝元素至新的数组中
   >
   > 应用场景不同：arraylist 查询快
   >
   > linkedlist：插入、删除快，查询慢
   >
   > 都不是线程安全
   >
   > 
   >
   > ArrayList动态扩容
   >
   > 初始化时可以设定数组大小，未设置默认为0；第一次添加元素，默认设置容量为10。
   >
   > - 在每次添加元素的时候，都会先调用ensureExplicitCapacity()方法，去判断elementData中容量，当容量不够时，调用grow()方法，去增大容量，首先通过 oldCapacity + (oldCapacity >> 1) 增大为elementData中原有容量的1.5倍，若容量仍然不够，则直接扩充至请求的容量。这样可以保证elementData每次都接近实际size的大小。
   >
   > - 扩容后，会调用 Arrays.copyOf()方法，将元素移动至新的数组中，所以每次使用ArrayList添加元素时，如果每次都需要扩容将会慢一些；同时在remove()时，也会去移动元素。Arrays.copyOf()实现是调用System.arraycopy()方法。

10. HashMap为什么长度是2的n次幂，数据结构，扩容（包括元素移动的细节），线程不安全的问题

11. CopyOnWriteList怎么保证线程安全，为什么这么做？

12. list和set的区别？以及各个实现类和底层实现

13. B+树与B树有什么区别？

14. 讲一下B+树的实现

15. 了解什么叫不可变类么？或者是叫不可变对象？

    > 不可变类（Immutable Objects）：当类的实例一经创建，其内容便不可改变，即无法修改其成员变量。
    >
    > 可变类（Mutable Objects）：类的实例创建后，可以修改其内容。
    >
    > Java 中八个基本类型的包装类和 String 类都属于不可变类，而其他的大多数类都属于可变类。

16. final的含义是什么？

    > final 修饰的字段初始化后是不可变的，而这种不可变就是指引用的不可变。具体就是该引用所指对象的内存地址是不可变的，但并非该对象不可变。

17. 成员变量都是final修饰的话，如何进行赋值？

    > final修饰变量必须在初始化的时候进行赋值，否则编译会报错
    >
    > 直接赋值
    >
    > 构造方法中赋值

18. HashMap 在扩容时, 对读写操作有什么特殊处理？

19. 为什么是6，变为链表

    > 中间有个差值7可以防止链表和树之间频繁的转换

20. hashmap的tableSizeFor方法

    > 计算一个接近当前值的2的幂的值
    >
    > 为扩容计算容量方法，每次为2倍，不能超过整型的最大值

21. 1.8相比1.7为什么头插变尾插？

    > JDK8以前是头插法，JDK8后是尾插法
    >
    > 1.8之后多了红黑树，不便使用头插法
    >
    > [rehash](https://blog.csdn.net/qq_35688140/article/details/100772864)





## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS

   > AQS为抽象队列同步器，构建锁底层框架

8. volatile关键字的作用，原理



9. synchronized

   > 锁升级
   >
   > 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁



10. threadPoolExcutor构造函数的各个参数详解

    > - corePoolSize：  核心线程数量，即使空闲，也不会终止（类似于今日某银行网点的值班窗口）
    > - maximumPoolSize： 最大线程数，线程池里能够容纳同时执行的最大线程数量，值必须大于1。（银行网点最多有这么个窗口，大于corePoolSize的可理解为今日可加班的窗口）
    > - workQueue： 任务队列，用于保存等待执行任务的阻塞队列，只包含有execute方法提交的Runnable。（类似于银行网点的候客区）
    > - keepAliveTime：空闲线程最大等待时间，当存在线程数大于核心线程数量，多余线程会在等待keepAliveTime长后销毁，直至线程数等于corePoolSize。（当人数变少了，加班窗口等待keepAliveTime时间后，没有客户，可以关闭）
    > - threadFactory：设置生成线程池中工作线程的线程工厂，可通过工厂为线程设置独特名称，一般默认。
    > - handler：线程池拒绝策略，当队列满了且工作线程数大于等于线程池中的最大线程数（maximumPoolSize），对新提交任务的处理策略。默认为AbortPolicy，抛出RejectedExecutionException异常。（银行窗口都满了，候客区也满了，其余再来人员就要拒绝）
    >
    > 流程，当corePoolSize满了，先去阻塞队列排队，阻塞队列满了，还能去启动（maximumPoolSize-corePoolSize）个线程，当都满了，再执行拒绝策略。

11. Java并发 future怎么使用 waitqueue

12. concurrenthashmap

    > ##### 介绍ConcurrentHashMap
    >
    > 线程安全的HashMap，基本结构一样。
    >
    > 相比于Java7，Java8中有了较大改变
    >
    > - ConcurrentHashMap，key和value均不能为null，会抛空指针异常，HashMap中当key值为null，设定hash为null
    >
    > - Java7中采用分段锁，将整个大数组划分为多个小段，每个小段对应一个锁，进行分段加锁；Java8中，进行了锁粒度的细化，锁为每个数组中元素，采用了 CAS + Synchronized来保证并发安全性。
    >
    >   
    >
    > ##### 2.2 put方法流程？
    >
    > - 若第一次table为null，先初始化一个默认容量为16的数组table。若不为null，根据(n - 1) & hash计算数组下标，若table[i]不存在元素为null时，不需要加锁，直接通过CAS写入元素，同时刻只有一个线程能够写入成功
    > - 若table[i]存在元素，根据table[i]的hash值判断是否正在扩容，若在扩容，协助扩容
    > - 若不在扩容，使用Synchronized同步，锁为table[i]元素，根据table[i]判断是进行链表还是树方式进行节点插入（因为转化为树后节点hash值为负数）。（锁的选择进行了优化）
    > - 插入完成后，如果链表节点数为8个，将链表转化为红黑树
    >
    > 因此，如果多个线程对同一个位置元素进行处理，才会使用Synchronized加锁，否则是可以多线程同时操作。
    >
    > 
    >
    > ##### 2.3 get方法流程？
    >
    > 读元素不需要加锁
    >
    > - 根据key计算hash值，找到数组位置table[i]
    > - 如果table[i]就为目标值，直接返回
    > - 若为红黑树，按照红黑树方式遍历
    > - 若为链表，按照链表方式

13. threadlocal原理

    > 作用
    >
    > ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，
    >
    > 在多线程环境下，能够防止自己的变量被其它线程篡改。
    >
    > 往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。
    >
    > 原理
    >
    > Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象
    >
    > 每个Thread维护着一个ThreadLocalMap的引用
    >
    > ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储
    >
    > 调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象
    >
    > （ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置，然后比较key）
    >
    > 调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象
    >
    > ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。
    >
    > ThreadLocal 本身并不存储值，它只是一个自己作为 key 来让线程从 ThreadLocalMap 中获取 value，正因为这个原因，所以 ThreadLocal 能实现 数据隔离，获取当前线程的局部变量值，不受其他线程影响
    >
    > 场景
    >
    > [ThreadLocal解决SimpleDateFormat多线程安全问题](https://blog.csdn.net/Android_Mrchen/article/details/84580474)
    >
    > 参数传递

14. syn和lock的区别，哪个更好？怎么选择？

    > 都是用来保证线程安全
    >
    > 使用上区别：
    >
    > syn关键字，JVM层面，lock为API层面
    >
    > syn不需要手动去释放锁，lock需要
    >
    > syn为可重入，非公平锁，lock可以公平可以非公平
    >
    > syn可以绑定多个条件

15. 锁粗化、锁消除

    > 锁消除
    >
    > 编译时，JIT通过逃逸分析技术，分析synchronized锁对象，如果synchronized修饰的同步代码块，不存在竞争，只有一个线程进行加锁访问，则会将monitorEnter、monitorExit去掉，去除锁，不需要加锁。
    >
    > 锁粗化
    >
    > 存在连续多个synchronized同步代码块进行加锁，释放锁，可以将其进行合并为一个，进行放大粗化，避免多个加锁释放锁。
    >
    > JIT逃逸分析
    >
    > [深入理解Java中的逃逸分析](https://blog.csdn.net/hollis_chuang/article/details/80922794)

16. 线程的状态，以及变化的时机

    > 五种状态
    >
    > 新建状态：new了之后，还未启动
    >
    > 运行（Runnable）：线程可能正在运行或者可能正在等待CPU时间片轮转到
    >
    > 等待状态（WAITING）:无限期等待，等待被其它线程唤醒
    >
    > 超时等待状态（TIMED_WAITING）：超时等待状态，若超时时间到，会由系统自动唤醒
    >
    > 阻塞状态（BLOCKED）：正在等待获取一个锁，不同于等待状态，等待状态是等待一段时间或者等待其它线程唤醒。程序等待进入同步区域时，会进入该种状态。
    >
    > 结束（Terminated）:终止状态，线程已经结束。

17. synchronized修饰同一个类的两个静态方法同步吗，为什么？

    > 同步，锁对象一样，都为类对象

18. 线程池设置了coreSize和maxSize之后，如果线程数量已经达到了coreSize，这个时候进来一个任务，会怎么处理？

    > 

19. 跟线程相关的方法介绍一下

    > yield，暂停当前正在执行的线程对象，并执行其他线程，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果
    >
    > join，join()方法的作用是调用join()方法的线程等待该线程完成后，才能继续运行main线程等到其他多个线程执行完毕后再继续执行。其他多个线程之间并不需要互相等待。父线程等待子线程结束之后才能继续运行
    >
    > sleep，睡眠，但是不释放锁
    >
    > interrupt，

20. retryLock了解吗？

21. Java里的轻量级锁？

    > CAS
    >
    > https://blog.csdn.net/lengxiao1993/article/details/81568130

22. 如何关闭线程？

    > Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。
    >
    > 只是改变中断状态，不会中断一个正在运行的线程。
    >
    > 当对一个线程，调用 interrupt() 时，
    > 1.如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。
    >
    > 2.如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。

23. 假如我还想隔离两个线程的数据, 怎么办？

    > Threadlocal

24. 本地线程和守护线程的区别，Thread.setDemon();

25. Threadlocal不remove掉会有什么问题？

    > ThreadLocal容易造成内存泄露
    >
    > Entry 继承了 WeakReference，所以 Entry 中的 key 是弱引用指向这个对象
    >
    > 原因
    >
    > 在方法调用的时候会创建 ThreadLocal 对象，就有一个强引用指向它，在调用 set() 后，线程的 ThreadLocalMap 对象里的 Entry 对象又有一个引用 key 指向它。如果后面这个引用 key 是强引用就会使方法执行完，栈帧中的强引用销毁了，对象还不能回收，造成严重的内存泄漏。
    >
    > 弱引用，保证了 key 指向的 ThreadLocal 对象能被及时回收，但是 v 指向的 value 对象是需要 ThreadLocalMap 调用 get 、set 时发现 key 为 null 时才会去回收整个 entry、value，因此弱引用不能 100% 保证内存不泄露。要在不使用某个 ThreadLocal 对象后，手动调用 remove 方法来清除它
    >
    > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219134347416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)





## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

3. 类加载过程

   > 使用到双亲委派模型
   >
   > 加载
   >
   > 验证
   >
   > 准备
   >
   > 解析
   >
   > 初始化

4. G1垃圾收集器

5. 标记清除的过程，标记清除算法如何给对象分配内存空间？

   > 标记清除先根据GC Roots找到存活对象，将其它不存活对象清除掉
   >
   > 适用于老年代，会造成大量空间碎片

6. cms算法的缺点

   > 并发标记清除，老年代
   >
   > 垃圾回收线程并发
   >
   > 四个步骤：
   >
   > 初始标记，根据GCRoots直接找到与之直接相关联的，单线程（STW）
   >
   > 并发标记，并发标记相连的
   >
   > 重新标记，多线程标记（STW）
   >
   > 并发清除，
   >
   > 
   >
   > 特点：CMS采用并发-标记算法，也会产生空间碎片，但低延时，能够快速响应，用于老年代。

7. java的虚引用是什么用的

   > 用于跟踪垃圾回收

8. 哪个区域不会发生内存溢出？

   > 
   >
   > 

9. 自己写的 Java 应用调优过哪些 JVM 参数, 为什么这么调优?

   > 使用-XX:+PrintGCDetails，打印gc回收日志
   >
   > 设置--Xms   --Xmx  设置堆内存大小
   >
   > 设置出现OOM时生成dump文件，-XX:+HeapDumpOnOutOfMemoryError
   >
   > 

10. 



## Spring

1. 讲讲spring boot启动流程
2. spring启动流程
3. spring bean生命周期
4. bean实例化过程
5. Spring MVC，说一下请求处理流程
6. Spring循环依赖有几种，如何解决
7. spring AOP
8. SpringBoot的特点
9. Spring IOC，AOP你的理解讲一下？
10. Spring注入方式知道哪些？
11. bean是线程安全的吗？







## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 微服务中服务注册中心的具体实现，为了防止服务注册中心集群挂掉或者要扩容应该怎么去配置和部署

5. dubbo原理，dubbo往zk写入的内容是什么

6. dubbo客户端负载均衡如何实现的，给你你如何实现，一步步提示和完善

7. fegin了解吗，手写过源码吗？

8. Dubbo服务暴露过程

9. Dubbo的spi和jdk的什么区别

10. Rabbitmq和kafka区别

11. Kafka适合什么场景，项目中是什么场景

12. Rabbit如何保证消息不丢失

13. Zk满足了CAP哪些特性

14. redis和zk分布式锁设计，使用注意事项

15. 分布式如何保证一致性

16. 负载均衡算法实现

17. 轮询和随机的缺点

18. 如果redis作为分布式锁的时候，主节点挂掉了，但是数据还没有同步到从节点，这种情况怎么办

19. 加锁的时候什么时候选择本地锁，什么时候选择分布式锁？

20. RabbitMQ优缺点讲一下？

21. cap理论

22. rocketmq的消费模式

23. MQ用在业务场景？MQ本身的优势是什么？一般什么情况下可以使用这个技术？核心本质原因是什么呢？开线程做不就可以了区别是什么？







## Netty

1. NIO 异步这些了解过吗 能不能说一下
2. netty线程模型
3. 怎么解决粘包问题
4. nio bio区别，nio底层epoll实现



## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现

   > 底层实现没有采用C语言的字符串类型
   >
   > 定义了新的数据结构，SDS即*Simple Dynamic String* ，是一种动态字符串
   >
   > ```c
   > struct sdshdr{
   > int len;/*字符串长度*/
   > int free;/*未使用的字节长度*/
   > char buf[];/*保存字符串的字节数组*/
   > }
   > ```
   >
   > 
   >
   > - C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。
   > - 避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。
   > - 空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。
   > - 惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。
   > - 二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用'\0'标识字符串的结束，如果我们存储的字符串中间出现'\0'，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。
   >
   >  字符串最大为512M

2. redis分布式锁的底层lua setnx

   > 

3. Redis有哪5种数据类型，底层实现结构

   > String
   >
   > Map     
   >
   > List
   >
   > Set
   >
   > Sorted Set

4. Set、Zset分别用于哪些场景

   > Set 为无序集合、自动去重，可用于存储类似文章标签。Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能
   >
   > zset为有序集合，去重，用于排行榜，按点击率排名
   >
   > zet应用场景： 延时队列、排行榜（点击榜）
   >
   > [Redis ZSet 的几种使用场景](https://zhuanlan.zhihu.com/p/147912757)

5. Redis是怎么删除过期key的

   > 由于Redis是将数据存储在内存中，容量有限，需要尽可能存储热点数据
   >
   > 两种方式
   >
   > 定期删除，定时100ms，随机抽取设置了过期时间的key，删除已经过期了的数据
   >
   > 惰性删除，当请求指定key的数据，会先判断是否设置了过期时间，是否超时，如果数据已过期，将不会返回
   >
   > 采用两种方式结合
   >
   > 
   >
   > 同时，redis还有缓存淘汰策略
   >
   > 

6. Redis有哪些持久化方式

   > 有两种
   >
   > RDB  执行过命令后，会将内存中存储的数据定时存储到硬盘上，存储在dump.rdb文件中，通过定时N秒内有M个操作的方式触发存储，该种方式容易造成数据丢失
   >
   > AOF  命令执行过后，会将命令记录到文件中，恢复时，直接将执行过命令重新执行一次，即可恢复，当存储命令较多，重启时Redis启动较慢
   >
   > 两种方式各有优势
   >
   > Redis4.0 混合持久化，两种方式结合

7. Redis常用的应用场景

   > 1）利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力
   >
   > 2）利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码
   >
   > 3）利用setnx命令的特性，可以实现分布式锁

8. Redis缓存穿透是什么，如何解决？

   > 缓存穿透，是有大量缓存、数据库中不存在的请求，请求直接打到数据库上
   >
   > 解决方案
   >
   > 1. 加校验，对明显有误的请求参数，不下发处理
   > 2. 当请求不存在数据，返回时，同步到redis中，设置null值，并设置过期时间（时间不能过长）
   > 3. 使用布隆过滤器

9. Redis缓存雪崩

   > Redis能够抗住每秒1w请求，但是同时有20w访问量，导致Redis扛不住
   >
   > 解决方案
   >
   > 1. 增加多级缓存，本地缓存，先判断本地缓存是否存在，
   > 2. 使用Redis高可用集群模式，保证高可用，使用RDB+AOF持久化，保证挂掉后可以快速恢复
   > 3. 限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。

10. Redis击穿

    > 缓存击穿，热点数据大量同时失效，同时大量用户访问，请求全部打到数据库
    >
    > 解决方案
    >
    > 1. 设置热点数据永不过期，通过定时任务去定时更新
    > 2. 采用分布式锁，热点数据失效，为了避免同时大量请求直接都去查询数据库，此时需要加锁，查询一次数据库后，更新至缓存，其它在等待锁的请求，进来后先再查询一遍缓存，此时缓存里已存在，可以直接返回，不必查询数据库。

11. Redis分布式锁

12. 项目中缓存使用场景，双写一致性怎么保证的

    > **情景1**： 先更新数据库，然后再去删除缓存，但是删除缓存失败，导致两者数据不一致
    >
    > **解决** 先删除缓存，再去更新数据库。如果更新数据库失败，缓存中为空，不会造成数据不一致
    >
    > **情景2**：读写并发情况下对同一数据进行读写，更新数据时，先把缓存删除了，但是在更新数据库期间，还未完成，有请求过来，先请求缓存为空，然后去请求数据库，读取到旧值，又把旧值更新到了缓存中，会导致数据不一致
    >
    > **解决** 针对修改同一个数据请求操作，进行hash，划分到一个队列中，一个队列对应一个线程。同时，读取数据时，发现数据不在缓存中，也可将重新读取数据和更新缓存操作，发送到同一个队列中，此时一个线程处理该队列中操作，串行化执行。

13. redis zset实现，跳跃表实现 时间复杂度

    > Zset表示有序集合
    >
    > 有序集合对象的编码可以是`ziplist散列表`或者`skiplist跳跃表`。同时满足以下条件时使用ziplist编码：
    >
    > - 元素数量小于128个
    > - 所有member的长度都小于64字节
    >
    > 不能满足上面两个条件的使用 skiplist 编码
    >
    > 跳跃表，查找元素时，跳表能够提供O(logN)
    >
    > - 当数据较少时，sorted set是由一个ziplist来实现的。
    > - 当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。
    >
    > [redis zset底层实现原理](https://www.cnblogs.com/yuanfang0903/p/12165394.html)
    >
    > **总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：**
    >
    > - 分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。
    > - 在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。
    > - 第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。
    > - 在skiplist中可以很方便地计算出每个元素的排名(rank)。

14. 跳跃表的思想是怎样的？哪里有用到跳跃表

    > 通常链表时按照一个节点中存储指向下个节点的指针，每次只能指向一个数据
    >
    > 但是跳跃表，在一个节点中可以有多层，能够同时指向后面多个节点。
    >
    > 在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度
    >
    > skiplist中元素有序排列
    >
    > skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。

15. redis长度过长怎么优化？哪个api，数据量超过多少效率会变低？

    [Redis 单key值过大 优化方式](https://blog.csdn.net/beyond59241/article/details/78889867/)

16. redis使用过程中出现过变慢的情况吗？

    > 使用复杂度高的命令
    >
    > 存储大的key值，可能会变慢
    >
    > 大量key集中过期
    >
    > 实例内存达到上限
    >
    > 网卡负载过高
    >
    > [Redis为什么会变慢](https://www.cnblogs.com/zt007/p/13612263.html)
    >
    > 可以通过查询慢日志，进行查询哪些操作导致变慢
    >
    > 首先设置Redis的慢日志阈值，只有超过阈值的命令才会被记录，这里的单位是微秒，例如设置慢日志的阈值为5毫秒，同时设置只保留最近1000条慢日志记录：

17. 

    



## 数据库MySQL

1. mysql的索引，innodb的行锁的理解

2. mysql索引==== B+ 日志问题（3个）

3. innodb和myisam区别

4. 如果由大量的增删操作，那么应该选择哪个存储引擎，为什么

5. myisam和innodb支持锁的粒度是怎样的

6. 索引都要怎么设计才能达到最优

7. mysql连接池满怎么排查

8. 间隙锁如何实现，幻读问题是什么，它是怎么通过间隙锁解决的，for update能否锁表

9. 分库分表怎么设计

10. 水平分表依据什么分？时间还是数据

11. 分库分表之后我想查询近期的订单，怎么查

12. select count(*)时InnoDB和MylSAM分别是怎么处理的

13. 聚簇索引和非聚簇索引的区别

14. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？

15. 事务有哪些隔离级别，分别解决了什么问题

16. 可重复读是怎么解决脏读的

17. 有俩事务，事务A：读、写(张三)、读  事务B：读、写(李四)、读，假如俩事务同时执行，结果如何

18. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？

19. 有一个表存在字段id（非主键、递增可重复）、name，如果有1000W条数据，查其中一条，有索引和没索引的情况下执行时间，建索引是否有用、会走索引吗、为什么

20. 说说MySQL索引为什么用B+树呢，b树，红黑树呢？为什么不用

21. MySql调优

    > **数据选型：**首先是数据选型方面进行优化，选取最适用的字段属性，数据的表越小，查询越快 
    >
    > **范式应用：**合理使用范式和反范式 
    >
    > **存储引擎的选择：**如果该数据库读操作较多，存储引擎选择MyISAM，如果是写操作多，选择innodb 
    >
    > **主键选择：**代理主键 
    >
    > **执行计划explain：**使用explain+sql测试sql语句执行情况，然后优化sql语句 
    >
    > 1.  注意的关键字：type关键字，通常达到range级别，最好是ref，而ref最好是一个常数。 
    >
    >  **索引优化：** 
    >
    > 1.  尽量在主键上添加使用索引 
    > 2.  利用覆盖索引、索引下推机制，注意组合索引的匹配原则， 
    > 3.  尽量使用唯一索引，避免使用普通索引 
    >
    > **查询优化：**这个应该被包含在执行计划中，但是个人觉得还是拆出来，其实我们在写的时候就该注意sql的效率，explain执行计划只是验证 
    >
    > 1.  优化数据访问，避免查询中出现筛选大量数据，可以通过limit限制； 
    > 2.  避免select * from table这种全表扫描的语句 
    > 3.  如果业务没有特殊规定数据，那么就尽量避免使用UNION，可以考虑UNION-ALL替换，因为后者不会过滤重复数据，效率高于UNION

22. 索引失效场景有哪些

23. mysql 幻读和间隙锁 分片实现事务，mysql原生实现分布式事务

24. 分库分表是以什么维度来划分的？划分的算法是怎样的，会不会出现数据分配不均衡的情况。

25. 事务的ACID，每一项是如何保证的

26. SQL查询优化怎么做

27. 4种事务隔离级别和分别的问题？

28. MySQL 如何分析一条语句的执行过程。delete from t1 limit 3和delete from t1的区别？





## 网络

1. HTTPS工作原理

2. TCP滑动窗口

   > 滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。

3. 三次握手的作用？过程？

   > 三次握手作用
   >
   > 客户端向服务端发起TCP connect连接时，会进行三次握手
   >
   > 通过三次握手作用，为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换`TCP窗口大小`信息
   >
   > 三次握手流程
   >
   > 第一次，客户端向服务端发起，携带SYN =1，初始序列seq=x，不能携带数据，客户端处于 `SYN_SEND` 状态
   >
   > 第二次，服务断接收到数据，携带SYN=1 ACK=1，初始序列seq=y，ack=x+1，不能携带数据，服务器处于 `SYN_RCVD` 的状态
   >
   > （证明客户端发送数据正常，服务端接收数据正常）
   >
   > 第三次，客户端接收到数据，进行响应，发送ACK=1，seq=x+1，ack=y+1，可以携带数据，服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接
   >
   > （证明客户端接收数据正常，服务端发送数据正常）
   >
   > ![三次握手.png](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28a45bd19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   >
   > 参考 
   >
   > https://juejin.cn/post/6844903958624878606

4. 为什么需要三次握手，两次不行吗

   > 三次握手的作用是为了确认双方的接收能力和发送能力是否正常
   >
   > 如果只有第一次，第二次，无法证明客户端的接受能力正常

5. http四次挥手，作用和过程是什么？

   > 作用，终止连接
   >
   > TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作
   >
   > 四次挥手过程
   >
   > 以客户端发起为例
   >
   > 第一步：客户端发送一个 FIN 报文，报文中会指定一个序列号。客户端处于`FIN_WAIT1` 状态。即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认
   >
   > 第二步：服务端收到FIN报文，回复确认报文（（ACK=1，确认号ack=u+1，序号seq=v），处于`CLOSE_WAIT`（关闭等待） 状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
   >
   > 第三步：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
   >
   > 第四步：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
   >
   > ![image.png](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28b49f652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   >
   > 参考 
   >
   > https://juejin.cn/post/6844903958624878606

6. 挥手为什么需要四次？

   > 在客服端第1次挥手时，服务端可能还在发送数据。
   >
   > 所以第2次挥手和第3次挥手不能合并。
   >
   > 
   >
   > 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

7. 2MSL等待状态指什么？

   > 在接收到第3次挥手后，会先进入TIME_WAIT（时间等待）状态，此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
   >
   > TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
   >
   > 
   >
   > 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

8. 四次挥手释放连接时，等待2MSL的意义?

   > **MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
   >
   > 服务端发送第三次挥手时处于LAST_ACK状态，客户端接受到第三次后，需要进行确认，发送ACK。
   >
   > 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为**这个ACK有可能丢失**，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。
   >
   > 服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
   >
   > 2. 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
   >
   > 目的就是为了完成正常的关闭。

9. 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

   > 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

10. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

    > TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
    > 
    > 

11. TCP/IP四层协议、ip在哪层

    > 应用层  http  TFTP  SMTP   （数据）
    >
    > 传输层  tcp/udp   （TCP包）
    >
    > 网络层  IP  ICMP     （IP包）
    >
    > 数据链路层    ARP 
    >
    > 物理层 

12. TCP有无状态

13. 输入url到页面加载完中间的流程

14. 线上用户出现502错误你怎么排查

15. 为什么连接的时候是三次握手，关闭的时候却是四次握手

16. tcp四次挥手过程？为什么等待2MSL

17. http常见状态码

18. TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些

19. TCP三次握手过程以及每次握手后的状态改变，为什么三次？ 为什么两次不行？

20. 301和302有什么区别

21. 504和500有什么区别

22. HTTPS 和 HTTP 有什么区别

23. http 1.0 1.1区别？





## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。

2. 设计一个缓存，在springboot启动时就加载好，你会怎么设计，把相应要用到的注解和类方法都描述一下

3. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发

4. Redis也扛不住了，万级流量会打到DB上，该怎么处理

5. 并发量很大，服务器宕机。你会怎么做

6. 一个url对应一个random值，要求设计一个系统，根据url查询random值，具体到表怎么设计，索引怎么加，代码怎么写？

7. 我有8件事要做，最要要同意返回处理结果，每件事要进行异步的方式去做。你怎么完成这个需求

8. 记录当日用户数量





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）
2. LRU实现，从O(n)到O(1)的各种方案，最理想的情况是什么
3. 最小覆盖子串
4. 如何判断一个链表是环链
5. 二叉树遍历，递归，非递归，层次遍历
6. 判断图中形成环 优先队列的删除节点方式
7. 两个数组如何找交集
8. 输入一行字符串
   找到里面最大的那个在后面加上(max)
   如果有多个就在每个后面都加上
   最后输出
   两次循环一次找最大
   第二次在每个最大后面加max
9. 最长回文串
10. 一个无序数组，求topk
11. 排序算法你知道那些？快速排序平均时间复杂度和最差时间复杂度。partition过程中最差情况是什么样的，描述一下

12.二分查找

13. 反转链表
14. 删除二叉搜索树的某一个节点
15. 给定数组，求第k大的数字
16. 求递增数组中相加等于10的元素对
17. 数组从下标最大的删与最小的删有什么区别
18. 合并两个有序的数组
19. 最长只有一种字符的字符串
20. [2个栈实现队列](https://www.nowcoder.com/jump/super-jump/practice?questionId=23281)
21. [合并有序链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=682)
22. [是否回文链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008769)
23. 快排
24. M*N 横向纵向均递增的矩阵找指定数
25. [两个排序数组找中位数](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008512)
26. [跳台阶](https://www.nowcoder.com/jump/super-jump/practice?questionId=23261)





需要过的题目

https://www.nowcoder.com/discuss/594301



## 设计模式

1. 单例模式
2. 策略模式
3. 装饰器模式
4. 适配器模式
5. 工厂模式



## Linux

1. 查看 CPU 的命令和磁盘 IO 的命令





## 其它

1. 你有遇到什么样的技术难题？
2. 有了解过领域模型相关知识？
3. 项目中最大的亮点，或者说项目中最大的难题是怎么解决的？

4. 日志大数据处理桶排序





## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)

[发个已经跪了的阿里一面，大概40分钟左右](https://www.nowcoder.com/discuss/593710)

[字节跳动1年半经验（双非非科班）一面面经](https://www.nowcoder.com/discuss/593554)

[顺丰后端社招面经](https://www.nowcoder.com/discuss/experience?tagId=639&order=3&companyId=0&phaseId=3)

[北京天润融通科技Java社招面经](https://www.nowcoder.com/discuss/591855)

[sap 上海 java 社招](https://www.nowcoder.com/discuss/588635)

[秋招社招经验(2020.12)](https://www.nowcoder.com/discuss/585741)

[携程社招Java二面面经](https://www.nowcoder.com/discuss/584725)

[社招-携程Java初面面经](https://www.nowcoder.com/discuss/584451)

[腾讯Java工程师社招面试经历](https://www.nowcoder.com/discuss/583626)

[腾讯Java社招面试经历记录](https://www.nowcoder.com/discuss/583601)

[小米社招Java岗一二面](https://www.nowcoder.com/discuss/583517?source_id=discuss_experience_nctrack&channel=-1)

[京东Java社招面试经历分享](https://www.nowcoder.com/discuss/583437?source_id=discuss_experience_nctrack&channel=-1)

[oppo社招Java面试经历分享](https://www.nowcoder.com/discuss/581405?source_id=discuss_experience_nctrack&channel=-1)

[字节跳动后端社招面试分享](https://www.nowcoder.com/discuss/578918?source_id=discuss_experience_nctrack&channel=-1)

[PingCAP后端社招面试经历](https://www.nowcoder.com/discuss/578850?source_id=discuss_experience_nctrack&channel=-1)

[1.3年工作经验，双非裸辞社招面经](https://www.nowcoder.com/discuss/578614?source_id=discuss_experience_nctrack&channel=-1)

[腾讯Java社招面经分享](https://www.nowcoder.com/discuss/578277?source_id=discuss_experience_nctrack&channel=-1)

# 面经



# 截至2021-02-03



## Java基础

1. hashmap里的hash函数你自己的话如何实现，如果你的hash函数总是取模后在固定的几个位置，如何优化这种情况

   > Java8针对hashcode计算方法已经进行了优化，会将hashcode值右移16位，然后再与自身进行按位与操作，计算存储位置时为(n-1)&hashcode的方式，此时hashcoded的32位都参与了运算，避免了在容量较小时，hashcoded的高位无法参与计算。

2. 



## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS

   > AQS为抽象队列同步器，构建锁底层框架

8. volatile



9. synchronized

   > 锁升级
   >
   > 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁



10. threadPoolExcutor构造函数的各个参数详解

    > - corePoolSize：  核心线程数量，即使空闲，也不会终止（类似于今日某银行网点的值班窗口）
    > - maximumPoolSize： 最大线程数，线程池里能够容纳同时执行的最大线程数量，值必须大于1。（银行网点最多有这么个窗口，大于corePoolSize的可理解为今日可加班的窗口）
    > - workQueue： 任务队列，用于保存等待执行任务的阻塞队列，只包含有execute方法提交的Runnable。（类似于银行网点的候客区）
    > - keepAliveTime：空闲线程最大等待时间，当存在线程数大于核心线程数量，多余线程会在等待keepAliveTime长后销毁，直至线程数等于corePoolSize。（当人数变少了，加班窗口等待keepAliveTime时间后，没有客户，可以关闭）
    > - threadFactory：设置生成线程池中工作线程的线程工厂，可通过工厂为线程设置独特名称，一般默认。
    > - handler：线程池拒绝策略，当队列满了且工作线程数大于等于线程池中的最大线程数（maximumPoolSize），对新提交任务的处理策略。默认为AbortPolicy，抛出RejectedExecutionException异常。（银行窗口都满了，候客区也满了，其余再来人员就要拒绝）
    >
    > 流程，当corePoolSize满了，先去阻塞队列排队，阻塞队列满了，还能去启动（maximumPoolSize-corePoolSize）个线程，当都满了，再执行拒绝策略。





## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

3. 类加载过程

   > 使用到双亲委派模型
   >
   > 加载
   >
   > 验证
   >
   > 准备
   >
   > 解析
   >
   > 初始化



## Spring

1. 讲讲spring boot启动流程
2. spring启动流程
3. spring bean生命周期
4. bean实例化过程







## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 微服务中服务注册中心的具体实现，为了防止服务注册中心集群挂掉或者要扩容应该怎么去配置和部署

5. dubbo原理，dubbo往zk写入的内容是什么

6. dubbo[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)负载均衡如何实现的，给你你如何实现，一步步提示和完善



## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现
2. redis分布式锁的底层lua setnx
3. Redis有哪5种数据类型
4. Set、Zset分别用于哪些场景
5. Redis是怎么删除过期key的
6. Redis有哪些持久化方式







## 数据库MySQL

1. mysql的索引，innodb的行锁的理解
2. mysql索引==== B+ 日志问题（3个）
3. innodb和myisam区别
4. 索引都要怎么设计才能达到最优
5. mysql连接池满怎么排查
6. 间隙锁如何实现，幻读问题是什么，它是怎么通过间隙锁解决的，for update能否锁表
7. 分库分表怎么设计
8. 水平分表依据什么分？时间还是数据
9. 分库分表之后我想查询近期的订单，怎么查
10. select count(*)时InnoDB和MylSAM分别是怎么处理的
11. 聚簇索引和非聚簇索引的区别
12. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？
13. 事务有哪些隔离级别，分别解决了什么问题
14. 可重复读是怎么解决脏读的
15. 有俩事务，事务A：读、写(张三)、读  事务B：读、写(李四)、读，假如俩事务同时执行，结果如何
16. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？
17. 有一个表存在字段id（非主键、递增可重复）、name，如果有1000W条数据，查其中一条，有索引和没索引的情况下执行时间，建索引是否有用、会走索引吗、为什么







## 网络

1. http四次挥手--报文传递参数是什么
2. HTTPS工作原理
3. TCP的三次握手四次挥手、滑动窗口
4. TCP/IP四层协议、ip在哪层
5. TCP有无状态





## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。

2. 设计一个缓存，在springboot启动时就加载好，你会怎么设计，把相应要用到的注解和类方法都描述一下

3. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发

4. Redis也扛不住了，万级流量会打到DB上，该怎么处理





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）
2. LRU实现，从O(n)到O(1)的各种方案，最理想的情况是什么
3. 最小覆盖子串
4. 如何判断一个链表是环链
5. 二叉树遍历，递归，非递归





需要过的题目

https://www.nowcoder.com/discuss/594301







## 其它

1. 你有遇到什么样的技术难题？
2. 







## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)

[发个已经跪了的阿里一面，大概40分钟左右](https://www.nowcoder.com/discuss/593710)

[字节跳动1年半经验（双非非科班）一面面经](https://www.nowcoder.com/discuss/593554)

[顺丰后端社招面经](https://www.nowcoder.com/discuss/experience?tagId=639&order=3&companyId=0&phaseId=3)




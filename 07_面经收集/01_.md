# 面经



# 截至2021-02-03



## Java基础

1. hashmap里的hash函数你自己的话如何实现，如果你的hash函数总是取模后在固定的几个位置，如何优化这种情况

   > Java8针对hashcode计算方法已经进行了优化，会将hashcode值右移16位，然后再与自身进行按位与操作，计算存储位置时为(n-1)&hashcode的方式，此时hashcoded的32位都参与了运算，避免了在容量较小时，hashcoded的高位无法参与计算。

2. HashMap初始化10000，如何扩容



## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS

   > AQS为抽象队列同步器，构建锁底层框架

8. volatile



9. synchronized

   > 锁升级
   >
   > 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁



10. threadPoolExcutor构造函数的各个参数详解

    > - corePoolSize：  核心线程数量，即使空闲，也不会终止（类似于今日某银行网点的值班窗口）
    > - maximumPoolSize： 最大线程数，线程池里能够容纳同时执行的最大线程数量，值必须大于1。（银行网点最多有这么个窗口，大于corePoolSize的可理解为今日可加班的窗口）
    > - workQueue： 任务队列，用于保存等待执行任务的阻塞队列，只包含有execute方法提交的Runnable。（类似于银行网点的候客区）
    > - keepAliveTime：空闲线程最大等待时间，当存在线程数大于核心线程数量，多余线程会在等待keepAliveTime长后销毁，直至线程数等于corePoolSize。（当人数变少了，加班窗口等待keepAliveTime时间后，没有客户，可以关闭）
    > - threadFactory：设置生成线程池中工作线程的线程工厂，可通过工厂为线程设置独特名称，一般默认。
    > - handler：线程池拒绝策略，当队列满了且工作线程数大于等于线程池中的最大线程数（maximumPoolSize），对新提交任务的处理策略。默认为AbortPolicy，抛出RejectedExecutionException异常。（银行窗口都满了，候客区也满了，其余再来人员就要拒绝）
    >
    > 流程，当corePoolSize满了，先去阻塞队列排队，阻塞队列满了，还能去启动（maximumPoolSize-corePoolSize）个线程，当都满了，再执行拒绝策略。





## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

3. 类加载过程

   > 使用到双亲委派模型
   >
   > 加载
   >
   > 验证
   >
   > 准备
   >
   > 解析
   >
   > 初始化



## Spring

1. 讲讲spring boot启动流程
2. spring启动流程
3. spring bean生命周期
4. bean实例化过程
5. Spring MVC，说一下请求处理流程
6. Spring循环依赖有几种，如何解决







## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 微服务中服务注册中心的具体实现，为了防止服务注册中心集群挂掉或者要扩容应该怎么去配置和部署

5. dubbo原理，dubbo往zk写入的内容是什么

6. dubbo客户端负载均衡如何实现的，给你你如何实现，一步步提示和完善

7. fegin了解吗，手写过源码吗？

8. Dubbo服务暴露过程

9. Dubbo的spi和jdk的什么区别

10. Rabbitmq和kafka区别

11. Kafka适合什么场景，项目中是什么场景

12. Rabbit如何保证消息不丢失

13. Zk满足了CAP哪些特性



## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现

   > 底层实现没有采用C语言的字符串类型
   >
   > 定义了新的数据结构，SDS即*Simple Dynamic String* ，是一种动态字符串
   >
   > ```c
   > struct sdshdr{
   > int len;/*字符串长度*/
   > int free;/*未使用的字节长度*/
   > char buf[];/*保存字符串的字节数组*/
   > }
   > ```
   >
   > 
   >
   > - C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。
   > - 避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。
   > - 空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。
   > - 惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。
   > - 二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用'\0'标识字符串的结束，如果我们存储的字符串中间出现'\0'，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。
   >
   >  字符串最大为512M

2. redis分布式锁的底层lua setnx

   > 

3. Redis有哪5种数据类型

   > String
   >
   > Map     
   >
   > List
   >
   > Set
   >
   > Sorted Set

4. Set、Zset分别用于哪些场景

   > Set 为无序集合、自动去重，可用于存储类似文章标签。Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能
   >
   > zset为有序集合，去重，用于排行榜，按点击率排名

5. Redis是怎么删除过期key的

   > 由于Redis是将数据存储在内存中，容量有限，需要尽可能存储热点数据
   >
   > 两种方式
   >
   > 定期删除，定时100ms，随机抽取设置了过期时间的key，删除已经过期了的数据
   >
   > 惰性删除，当请求指定key的数据，会先判断是否设置了过期时间，是否超时，如果数据已过期，将不会返回
   >
   > 采用两种方式结合
   >
   > 
   >
   > 同时，redis还有缓存淘汰策略
   >
   > 

6. Redis有哪些持久化方式

   > 有两种
   >
   > RDB  执行过命令后，会将内存中存储的数据定时存储到硬盘上，存储在dump.rdb文件中，通过定时N秒内有M个操作的方式触发存储，该种方式容易造成数据丢失
   >
   > AOF  命令执行过后，会将命令记录到文件中，恢复时，直接将执行过命令重新执行一次，即可恢复，当存储命令较多，重启时Redis启动较慢
   >
   > 两种方式各有优势
   >
   > Redis4.0 混合持久化，两种方式结合

7. Redis常用的应用场景

   > 1）利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力
   >
   > 2）利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码
   >
   > 3）利用setnx命令的特性，可以实现分布式锁

8. Redis缓存穿透是什么，如何解决？

   > 缓存穿透，是有大量缓存、数据库中不存在的请求，请求直接打到数据库上
   >
   > 解决方案
   >
   > 1. 加校验，对明显有误的请求参数，不下发处理
   > 2. 当请求不存在数据，返回时，同步到redis中，设置null值，并设置过期时间（时间不能过长）
   > 3. 使用布隆过滤器

9. Redis缓存雪崩

   > Redis能够抗住每秒1w请求，但是同时有20w访问量，导致Redis扛不住
   >
   > 解决方案
   >
   > 1. 增加多级缓存，本地缓存，先判断本地缓存是否存在，
   > 2. 使用Redis高可用集群模式，保证高可用，使用RDB+AOF持久化，保证挂掉后可以快速恢复
   > 3. 限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。

10. Redis击穿

    > 缓存击穿，热点数据大量同时失效，同时大量用户访问，请求全部打到数据库
    >
    > 解决方案
    >
    > 1. 设置热点数据永不过期，通过定时任务去定时更新
    > 2. 采用分布式锁，热点数据失效，为了避免同时大量请求直接都去查询数据库，此时需要加锁，查询一次数据库后，更新至缓存，其它在等待锁的请求，进来后先再查询一遍缓存，此时缓存里已存在，可以直接返回，不必查询数据库。

11. Redis分布式锁

12. 项目中缓存使用场景，双写一致性怎么保证的

13. 

    



## 数据库MySQL

1. mysql的索引，innodb的行锁的理解

2. mysql索引==== B+ 日志问题（3个）

3. innodb和myisam区别

4. 索引都要怎么设计才能达到最优

5. mysql连接池满怎么排查

6. 间隙锁如何实现，幻读问题是什么，它是怎么通过间隙锁解决的，for update能否锁表

7. 分库分表怎么设计

8. 水平分表依据什么分？时间还是数据

9. 分库分表之后我想查询近期的订单，怎么查

10. select count(*)时InnoDB和MylSAM分别是怎么处理的

11. 聚簇索引和非聚簇索引的区别

12. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？

13. 事务有哪些隔离级别，分别解决了什么问题

14. 可重复读是怎么解决脏读的

15. 有俩事务，事务A：读、写(张三)、读  事务B：读、写(李四)、读，假如俩事务同时执行，结果如何

16. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？

17. 有一个表存在字段id（非主键、递增可重复）、name，如果有1000W条数据，查其中一条，有索引和没索引的情况下执行时间，建索引是否有用、会走索引吗、为什么

18. 说说MySQL索引为什么用B+树呢，b树，红黑树呢？为什么不用

19. MySql调优

    > **数据选型：**首先是数据选型方面进行优化，选取最适用的字段属性，数据的表越小，查询越快 
    >
    > **范式应用：**合理使用范式和反范式 
    >
    > **存储引擎的选择：**如果该数据库读操作较多，存储引擎选择MyISAM，如果是写操作多，选择innodb 
    >
    > **主键选择：**代理主键 
    >
    > **执行计划explain：**使用explain+sql测试sql语句执行情况，然后优化sql语句 
    >
    > 1.  注意的关键字：type关键字，通常达到range级别，最好是ref，而ref最好是一个常数。 
    >
    >  **索引优化：** 
    >
    > 1.  尽量在主键上添加使用索引 
    > 2.  利用覆盖索引、索引下推机制，注意组合索引的匹配原则， 
    > 3.  尽量使用唯一索引，避免使用普通索引 
    >
    > **查询优化：**这个应该被包含在执行计划中，但是个人觉得还是拆出来，其实我们在写的时候就该注意sql的效率，explain执行计划只是验证 
    >
    > 1.  优化数据访问，避免查询中出现筛选大量数据，可以通过limit限制； 
    > 2.  避免select * from table这种全表扫描的语句 
    > 3.  如果业务没有特殊规定数据，那么就尽量避免使用UNION，可以考虑UNION-ALL替换，因为后者不会过滤重复数据，效率高于UNION

20. 索引失效场景有哪些





## 网络

1. http四次挥手--报文传递参数是什么
2. HTTPS工作原理
3. TCP的三次握手四次挥手、滑动窗口
4. TCP/IP四层协议、ip在哪层
5. TCP有无状态





## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。

2. 设计一个缓存，在springboot启动时就加载好，你会怎么设计，把相应要用到的注解和类方法都描述一下

3. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发

4. Redis也扛不住了，万级流量会打到DB上，该怎么处理





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）
2. LRU实现，从O(n)到O(1)的各种方案，最理想的情况是什么
3. 最小覆盖子串
4. 如何判断一个链表是环链
5. 二叉树遍历，递归，非递归





需要过的题目

https://www.nowcoder.com/discuss/594301







## 其它

1. 你有遇到什么样的技术难题？
2. 有了解过领域模型相关知识？
3. 项目中最大的亮点，或者说项目中最大的难题是怎么解决的？







## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)

[发个已经跪了的阿里一面，大概40分钟左右](https://www.nowcoder.com/discuss/593710)

[字节跳动1年半经验（双非非科班）一面面经](https://www.nowcoder.com/discuss/593554)

[顺丰后端社招面经](https://www.nowcoder.com/discuss/experience?tagId=639&order=3&companyId=0&phaseId=3)

[北京天润融通科技Java社招面经](https://www.nowcoder.com/discuss/591855)

[有赞云社招Java面经](https://www.nowcoder.com/discuss/589908)

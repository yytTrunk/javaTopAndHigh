

# 面经



# 截至2021-02-03



## Java基础

1. hashmap里的hash函数你自己的话如何实现，如果你的hash函数总是取模后在固定的几个位置，如何优化这种情况

   > Java8针对hashcode计算方法已经进行了优化，会将hashcode值右移16位，然后再与自身进行按位与操作，计算存储位置时为(n-1)&hashcode的方式，此时hashcoded的32位都参与了运算，避免了在容量较小时，hashcoded的高位无法参与计算。

2. HashMap初始化10000，如何扩容

3. hashmap如何get一个元素

4. hashmap底层查找的时间复杂度

5. 谈谈对多态的理解

6. 面向对象的特性

   > 前提是抽象
   >
   > 封装 ：继承 多态
   >
   > 继承：层次化结构，类继承、接口继承
   >
   > 多态：实现多态两种方式：
   >
   > 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
   >
   > 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
   >
   > 多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作，
   >
   > 封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）

7. 面向对象的设计原则

   > 单一职责原则：一个类应该仅有一个引起它变化的原因
   >
   > 开放封闭原则：对扩展是开放的，对更改是封闭的
   >
   > 里氏替换原则：子类可以替换父类并且出现在父类能够出现的任何地方
   >
   > （父类应尽可能使用接口或者抽象类来实现，子类通过实现了父类接口，能够替父类的使用地方）
   >
   > 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象，面向接口编程
   >
   > ISP 接口隔离原则：使用多个专门的接口比使用单个接口要好的多

8. 什么时候需要重写父类的方法

9. arraylist和linkedlist的区别

   > 底层实现不同：数组，双向链表
   >
   > 特点不同：数组，内存连续；链表不连续，内存利用率高
   >
   > 数组指定位置插入、删除元素较慢，需要拷贝元素至新的数组中
   >
   > 应用场景不同：arraylist 查询快
   >
   > linkedlist：插入、删除快，查询慢
   >
   > 都不是线程安全
   >
   > 
   >
   > ArrayList动态扩容
   >
   > 初始化时可以设定数组大小，未设置默认为0；第一次添加元素，默认设置容量为10。
   >
   > - 在每次添加元素的时候，都会先调用ensureExplicitCapacity()方法，去判断elementData中容量，当容量不够时，调用grow()方法，去增大容量，首先通过 oldCapacity + (oldCapacity >> 1) 增大为elementData中原有容量的1.5倍，若容量仍然不够，则直接扩充至请求的容量。这样可以保证elementData每次都接近实际size的大小。
   >
   > - 扩容后，会调用 Arrays.copyOf()方法，将元素移动至新的数组中，所以每次使用ArrayList添加元素时，如果每次都需要扩容将会慢一些；同时在remove()时，也会去移动元素。Arrays.copyOf()实现是调用System.arraycopy()方法。

10. HashMap为什么长度是2的n次幂，数据结构，扩容（包括元素移动的细节），线程不安全的问题

11. CopyOnWriteList怎么保证线程安全，为什么这么做？

12. list和set的区别？以及各个实现类和底层实现

13. B+树与B树有什么区别？

14. 讲一下B+树的实现

15. 了解什么叫不可变类么？或者是叫不可变对象？

    > 不可变类（Immutable Objects）：当类的实例一经创建，其内容便不可改变，即无法修改其成员变量。
    >
    > 可变类（Mutable Objects）：类的实例创建后，可以修改其内容。
    >
    > Java 中八个基本类型的包装类和 String 类都属于不可变类，而其他的大多数类都属于可变类。

16. final的含义是什么？

    > final 修饰的字段初始化后是不可变的，而这种不可变就是指引用的不可变。具体就是该引用所指对象的内存地址是不可变的，但并非该对象不可变。

17. 成员变量都是final修饰的话，如何进行赋值？

    > final修饰变量必须在初始化的时候进行赋值，否则编译会报错
    >
    > 直接赋值
    >
    > 构造方法中赋值

18. HashMap 在扩容时, 对读写操作有什么特殊处理？

19. 为什么是6，变为链表

    > 中间有个差值7可以防止链表和树之间频繁的转换

20. hashmap的tableSizeFor方法

    > 计算一个接近当前值的2的幂的值
    >
    > 为扩容计算容量方法，每次为2倍，不能超过整型的最大值

21. 1.8相比1.7为什么头插变尾插？

    > JDK8以前是头插法，JDK8后是尾插法
    >
    > 1.8之后多了红黑树，不便使用头插法
    >
    > [rehash](https://blog.csdn.net/qq_35688140/article/details/100772864)





## Java并发

1. 进程间的通信方式

   > Linux中
   >
   > 管道（使用 |）（ps  aux | grep java）
   >
   > 消息队列，保存在内核中的消息链表
   >
   > 共享内存，拿出一块虚拟地址空间来，映射到相同的物理内存中
   >
   > 信号量，整型计数器，通过PV操作，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据（多进程竞争同个共享资源会造成数据的错乱）
   >
   > 信号，发送信号给某一进程，例如 kill -9   ctrl c    
   >
   > socket，跨网络与不同主机上的进程之间网络通信
   >
   > [参考](https://www.javazhiyin.com/65329.html)
   >
   > Java中进程通信，可以通过共享变量和管道流
   >
   > 共享变量，访问共享变量方式（需要注意同步，对于文件操作，可以采用文件锁）
   >
   > 管道流，例如使用Java调用C代码编写程序，通过管道方式读取结果，需要注意及时清理管道里数据，否则过大会报错

   

2. java自带的创建线程方式

   > 继承Thread类，
   >
   > 实现Runnable接口
   >
   > 使用线程池
   >
   > 实现Callable接口，重写call方法

3. Synchronized关键字底层实现

   > 底层实现
   >
   > synchronized是内置锁，可重入，内部通过Monitor监视器实现。
   >
   > synchronized修饰方法，flags多了`ACC_SYNCHRONIZED`字段，用于表明该方法被关键字synchronized修饰，为同步方法。线程在执行到方法时，发现有`ACC_SYNCHRONIZED`标志，会先去获取监视器，获取到监视器，继续执行，执行完毕后释放监视器。后来的线程，获取不到监视器，会被阻塞。
   >
   > synchronized修饰代码块，同步代码块，前后多了`monitorenter`和`monitorexit`指令，用于表明同步代码块的开始与结束。线程执行到`monitorenter`后，会去尝试获取锁对象monitor，本质是对monitor对象加锁，该对象存放在Java对象的对象头中，不同的配置表示不同的锁类型，每个Java对象存在对象头，因此都可以作为锁对象。synchronized可重入，monitor对象中还存在一个entryList，当想要竞争锁的线程会被加入到这个entryList中。monitor对象中还存在一个计数器_count，当计数器为0时，等待的线程通过CAS竞争获取，当竞争获取到锁后，monitor对象中的_owner指针将指向该线程，同时计数器值加1。在执行到`monitorexit`时，计数器值减1，为0时，即释放锁。如果获取对象锁失败，会被阻塞，直至获取到锁。
   >
   > 当在synchronized代码块中执行了wait方法，会把线程加入到waitSet中，其它线程执行notify操作后，会去唤醒waitSet中线程。
   >
   > 如上反编译后，同时多了异常表，用于捕获同步代码块中异常，当5-15行出现 异常，跳转第18行执行，再次执行一次`monitorexit`指令，用于释放锁。如果没有异常，则会正常执行第14行进行释放锁。因此，synchronized也是会通过try-finally来隐式释放锁。
   >
   > 
   >
   > 使用
   >
   > 修饰实例方法，锁对象为实例化对象
   >
   > 修饰静态方法，锁对象为类对象
   >
   > 修饰同步代码块，锁对象为自定义锁对象

   

4. 乐观锁--悲观锁

   > 并不是指一种锁，而是一种锁策略，区别在于是否会提前判断存不存在竞争
   >
   > 乐观锁，每次默认不存在竞争，不上锁，尝试去执行，执行时会判断数据是否被修改过。（CAS、原子类）（采用版本号机制或者CAS实现）（适用读多写少）
   >
   > 悲观锁，每次操作都需要加锁后，才能继续执行。（写锁）

5. 线程池队列有哪几种

   > ![](https://user-gold-cdn.xitu.io/2020/4/13/17171b857e1ed12f?w=1694&h=764&f=png&s=314044)

6. 并发大的情况下，核心线程池该如何设置参数？大流量进来会不会堵塞整个流程（通过扩容服务器的方式?）

   > 并发大情况，如果并发线程数设置过多，线程不断进行切换，会影响性能
   >
   > 可以根据CPU密集型还是IO密集型任务进行配置
   >
   > 
   >
   > 线程池参数动态化

7. AQS

   > AQS为抽象队列同步器，构建锁底层框架

8. volatile关键字的作用，原理



9. synchronized

   > 锁升级
   >
   > 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁



10. threadPoolExcutor构造函数的各个参数详解

    > - corePoolSize：  核心线程数量，即使空闲，也不会终止（类似于今日某银行网点的值班窗口）
    > - maximumPoolSize： 最大线程数，线程池里能够容纳同时执行的最大线程数量，值必须大于1。（银行网点最多有这么个窗口，大于corePoolSize的可理解为今日可加班的窗口）
    > - workQueue： 任务队列，用于保存等待执行任务的阻塞队列，只包含有execute方法提交的Runnable。（类似于银行网点的候客区）
    > - keepAliveTime：空闲线程最大等待时间，当存在线程数大于核心线程数量，多余线程会在等待keepAliveTime长后销毁，直至线程数等于corePoolSize。（当人数变少了，加班窗口等待keepAliveTime时间后，没有客户，可以关闭）
    > - threadFactory：设置生成线程池中工作线程的线程工厂，可通过工厂为线程设置独特名称，一般默认。
    > - handler：线程池拒绝策略，当队列满了且工作线程数大于等于线程池中的最大线程数（maximumPoolSize），对新提交任务的处理策略。默认为AbortPolicy，抛出RejectedExecutionException异常。（银行窗口都满了，候客区也满了，其余再来人员就要拒绝）
    >
    > 流程，当corePoolSize满了，先去阻塞队列排队，阻塞队列满了，还能去启动（maximumPoolSize-corePoolSize）个线程，当都满了，再执行拒绝策略。

11. Java并发 future怎么使用 waitqueue

12. concurrenthashmap

    > ##### 介绍ConcurrentHashMap
    >
    > 线程安全的HashMap，基本结构一样。
    >
    > 相比于Java7，Java8中有了较大改变
    >
    > - ConcurrentHashMap，key和value均不能为null，会抛空指针异常，HashMap中当key值为null，设定hash为null
    >
    > - Java7中采用分段锁，将整个大数组划分为多个小段，每个小段对应一个锁，进行分段加锁；Java8中，进行了锁粒度的细化，锁为每个数组中元素，采用了 CAS + Synchronized来保证并发安全性。
    >
    >   
    >
    > ##### 2.2 put方法流程？
    >
    > - 若第一次table为null，先初始化一个默认容量为16的数组table。若不为null，根据(n - 1) & hash计算数组下标，若table[i]不存在元素为null时，不需要加锁，直接通过CAS写入元素，同时刻只有一个线程能够写入成功
    > - 若table[i]存在元素，根据table[i]的hash值判断是否正在扩容，若在扩容，协助扩容
    > - 若不在扩容，使用Synchronized同步，锁为table[i]元素，根据table[i]判断是进行链表还是树方式进行节点插入（因为转化为树后节点hash值为负数）。（锁的选择进行了优化）
    > - 插入完成后，如果链表节点数为8个，将链表转化为红黑树
    >
    > 因此，如果多个线程对同一个位置元素进行处理，才会使用Synchronized加锁，否则是可以多线程同时操作。
    >
    > 
    >
    > ##### 2.3 get方法流程？
    >
    > 读元素不需要加锁
    >
    > - 根据key计算hash值，找到数组位置table[i]
    > - 如果table[i]就为目标值，直接返回
    > - 若为红黑树，按照红黑树方式遍历
    > - 若为链表，按照链表方式

13. threadlocal原理

    > 作用
    >
    > ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，
    >
    > 在多线程环境下，能够防止自己的变量被其它线程篡改。
    >
    > 往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。
    >
    > ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。
    >
    > 
    >
    > 原理
    >
    > Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象
    >
    > 每个Thread维护着一个ThreadLocalMap的引用
    >
    > ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储
    >
    > 调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象
    >
    > （ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置，然后比较key）
    >
    > 调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象
    >
    > ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。
    >
    > ThreadLocal 本身并不存储值，它只是一个自己作为 key 来让线程从 ThreadLocalMap 中获取 value，正因为这个原因，所以 ThreadLocal 能实现 数据隔离，获取当前线程的局部变量值，不受其他线程影响
    >
    > 
    >
    > ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据。ThreadLocalMap 会初始化一个长度为 16 的 Entry 数组，每个 Entry 对象用于保存 key-value 键值对。
    >
    > 调用 ThreadLocal.set() 添加 Entry 对象时，是如何解决 Hash 冲突？
    >
    > 每个 ThreadLocal 在初始化时都会有一个 Hash 值为 threadLocalHashCode，每增加一个 ThreadLocal， Hash 值就会固定增加一个魔术 HASH_INCREMENT = 0x61c88647。为什么取 0x61c88647 这个魔数呢？实验证明，通过 0x61c88647 累加生成的 threadLocalHashCode 与 2 的幂取模，得到的结果可以较为均匀地分布在长度为 2 的幂大小的数组中。
    >
    > 简单的数据模拟 ThreadLocal.set() 的过程是如何解决 Hash 冲突的。
    >
    > - threadLocalHashCode = 4，threadLocalHashCode & 15 = 4；此时数据应该放在数组下标为 4 的位置。下标 4 的位置正好没有数据，可以存放。
    >
    >
    > - threadLocalHashCode = 19，threadLocalHashCode & 15 = 4；但是下标 4 的位置已经有数据了，如果当前需要添加的 Entry 与下标 4 位置已存在的 Entry 两者的 key 相同，那么该位置 Entry 的 value 将被覆盖为新的值。我们假设 key 都是不相同的，所以此时需要向后移动一位，下标 5 的位置没有冲突，可以存放。
    >
    >
    > - threadLocalHashCode = 33，threadLocalHashCode & 15 = 3；下标 3 的位置已经有数据，向后移一位，下标 4 位置还是有数据，继续向后查找，发现下标 6 没有数据，可以存放。
    >
    > ThreadLocal.get() 的过程也是类似的，也是根据 threadLocalHashCode 的值定位到数组下标，然后判断当前位置 Entry 对象与待查询 Entry 对象的 key 是否相同，如果不同，继续向下查找。由此可见，ThreadLocal.set()/get() 方法在数据密集时很容易出现 Hash 冲突，需要 O(n) 时间复杂度解决冲突问题，效率较低。
    >
    > 
    >
    > Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。如果 key 都是强引用，当 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。
    >
    > 虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal 不再使用被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？在执行 ThreadLocal.set()/get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，记得在 finally 代码块中进行清理，保持良好的编码意识。
    >
    > 场景
    >
    > [ThreadLocal解决SimpleDateFormat多线程安全问题](https://blog.csdn.net/Android_Mrchen/article/details/84580474)
    >
    > 参数传递
    >
    > 总结
    >
    > 1. Thread类里存在个threadlocalMap变量
    >
    > 2. threadlocalMap中key为currentThread，value值为一个entry， 
    >
    > 3. entry中key为ThreadLocal，value为需要存储的value值
    >
    >    https://zhuanlan.zhihu.com/p/238231572

    

    

14. syn和lock的区别，哪个更好？怎么选择？

    > 都是用来保证线程安全
    >
    > 使用上区别：
    >
    > syn关键字，JVM层面，lock为API层面
    >
    > syn不需要手动去释放锁，lock需要
    >
    > syn为可重入，非公平锁，lock可以公平可以非公平
    >
    > syn可以绑定多个条件

15. 锁粗化、锁消除

    > 锁消除
    >
    > 编译时，JIT通过逃逸分析技术，分析synchronized锁对象，如果synchronized修饰的同步代码块，不存在竞争，只有一个线程进行加锁访问，则会将monitorEnter、monitorExit去掉，去除锁，不需要加锁。
    >
    > 锁粗化
    >
    > 存在连续多个synchronized同步代码块进行加锁，释放锁，可以将其进行合并为一个，进行放大粗化，避免多个加锁释放锁。
    >
    > JIT逃逸分析
    >
    > [深入理解Java中的逃逸分析](https://blog.csdn.net/hollis_chuang/article/details/80922794)

16. 线程的状态，以及变化的时机

    > 五种状态
    >
    > 新建状态：new了之后，还未启动
    >
    > 运行（Runnable）：线程可能正在运行或者可能正在等待CPU时间片轮转到
    >
    > 等待状态（WAITING）:无限期等待，等待被其它线程唤醒
    >
    > 超时等待状态（TIMED_WAITING）：超时等待状态，若超时时间到，会由系统自动唤醒
    >
    > 阻塞状态（BLOCKED）：正在等待获取一个锁，不同于等待状态，等待状态是等待一段时间或者等待其它线程唤醒。程序等待进入同步区域时，会进入该种状态。
    >
    > 结束（Terminated）:终止状态，线程已经结束。

17. synchronized修饰同一个类的两个静态方法同步吗，为什么？

    > 同步，锁对象一样，都为类对象

18. 线程池设置了coreSize和maxSize之后，如果线程数量已经达到了coreSize，这个时候进来一个任务，会怎么处理？

    > 

19. 跟线程相关的方法介绍一下

    > yield，暂停当前正在执行的线程对象，并执行其他线程，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果
    >
    > join，join()方法的作用是调用join()方法的线程等待该线程完成后，才能继续运行main线程等到其他多个线程执行完毕后再继续执行。其他多个线程之间并不需要互相等待。父线程等待子线程结束之后才能继续运行
    >
    > sleep，睡眠，但是不释放锁
    >
    > interrupt，

20. retryLock了解吗？

21. Java里的轻量级锁？

    > CAS
    >
    > https://blog.csdn.net/lengxiao1993/article/details/81568130

22. 如何关闭线程？

    > Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。
    >
    > 只是改变中断状态，不会中断一个正在运行的线程。
    >
    > 当对一个线程，调用 interrupt() 时，
    > 1.如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。
    >
    > 2.如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。

23. 假如我还想隔离两个线程的数据, 怎么办？

    > Threadlocal

24. 本地线程和守护线程的区别，Thread.setDemon();

25. Threadlocal不remove掉会有什么问题？

    > ThreadLocal容易造成内存泄露
    >
    > Entry 继承了 WeakReference，所以 Entry 中的 key 是弱引用指向这个对象
    >
    > 原因
    >
    > 在方法调用的时候会创建 ThreadLocal 对象，就有一个强引用指向它，在调用 set() 后，线程的 ThreadLocalMap 对象里的 Entry 对象又有一个引用 key 指向它。如果后面这个引用 key 是强引用就会使方法执行完，栈帧中的强引用销毁了，对象还不能回收，造成严重的内存泄漏。
    >
    > 弱引用，保证了 key 指向的 ThreadLocal 对象能被及时回收，但是 v 指向的 value 对象是需要 ThreadLocalMap 调用 get 、set 时发现 key 为 null 时才会去回收整个 entry、value，因此弱引用不能 100% 保证内存不泄露。要在不使用某个 ThreadLocal 对象后，手动调用 remove 方法来清除它
    >
    > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219134347416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)





## JVM

1. 双亲委派机制

   > **类加载器作用**：加载class文件
   >
   > **类加载器分类**
   >
   > - 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
   > - 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
   > - 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类
   >
   > **加载类时使用双亲委派模型，过程如下**
   >
   > - 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
   > - 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
   > - 加载不到则会报ClassNotFoundException
   >
   > **例子**
   >
   > 比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？
   >
   > 不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。

2. JVM的底层结构---GC算法---可达性分析

3. 类加载过程

   > 使用到双亲委派模型
   >
   > 加载
   >
   > 验证
   >
   > 准备
   >
   > 解析
   >
   > 初始化

4. G1垃圾收集器

5. 标记清除的过程，标记清除算法如何给对象分配内存空间？

   > 标记清除先根据GC Roots找到存活对象，将其它不存活对象清除掉
   >
   > 适用于老年代，会造成大量空间碎片

6. cms算法的缺点

   > 并发标记清除，老年代
   >
   > 垃圾回收线程并发
   >
   > 四个步骤：
   >
   > 初始标记，根据GCRoots直接找到与之直接相关联的，单线程（STW）
   >
   > 并发标记，并发标记相连的
   >
   > 重新标记，多线程标记（STW）
   >
   > 并发清除，
   >
   > 
   >
   > 特点：CMS采用并发-标记算法，也会产生空间碎片，但低延时，能够快速响应，用于老年代。

7. java的虚引用是什么用的

   > 用于跟踪垃圾回收

8. 哪个区域不会发生内存溢出？

   > 
   >
   > 

9. 自己写的 Java 应用调优过哪些 JVM 参数, 为什么这么调优?

   > 使用-XX:+PrintGCDetails，打印gc回收日志
   >
   > 设置--Xms   --Xmx  设置堆内存大小
   >
   > 设置出现OOM时生成dump文件，-XX:+HeapDumpOnOutOfMemoryError
   >
   > 

10. 



## Spring

1. 讲讲spring boot启动流程
2. spring启动流程
3. spring bean生命周期
4. bean实例化过程
5. Spring MVC，说一下请求处理流程
6. Spring循环依赖有几种，如何解决
7. spring AOP
8. SpringBoot的特点
9. Spring IOC，AOP你的理解讲一下？
10. Spring注入方式知道哪些？
11. bean是线程安全的吗？







## 分布式

1. 分布式事务

2. 限流算法------令牌桶和漏抖算法

3. 幂等问题？--项目中的幂等问题--本地消息表（空间换时间的概念）

   > 幂等问题本身就是一个常规化的问题，在一般情况下，都是需要通过各种手段去处理，比如增加冗余字段，比如增加校验逻辑，或者增加补偿逻辑等。这里的核心点就是，需要花费更多的时间和空间去对幂等进行校验，那么亮点应该是如何平衡时间和空间的消耗

4. 微服务中服务注册中心的具体实现，为了防止服务注册中心集群挂掉或者要扩容应该怎么去配置和部署

5. dubbo原理？

   > dubbo整体氛围10层
   >
   > 分为消费端和服务提供端
   >
   > 服务提供端，会将服务接口暴露出去，在注册中心，进行注册。
   >
   > 服务消费端，会从注册中心，拉取注册中心的服务提供信息。
   >
   > 当需要调用接口时，通过接口，生成动态代理对象，使用负载均衡，查找到对应提供服务的设备，选择传输的协议类型，使用dubbo协议，按照格式将请求进行封装为Request，使用Netty消息传输，同时需要序列化
   >
   > 到达服务提供者时是个逆过程，先进行反序列化，解析Request，根据传输协议解析出请求内容，根据动态代理，找到对应的类，完成方法调用

6. dubbo往zk写入的内容是什么？

   > - 根节点 /dubbo
   > - 服务名称 (类全限定名) /com.xx.XxService
   > - 类型 providers 或者 consumers
   > - url (ip:port)

7. dubbo客户端负载均衡如何实现的，给你你如何实现，一步步提示和完善

   > Dubbo内置了4种负载均衡策略:
   >
   > 1. RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的**默认**负载均衡策略。
   > 2. RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。
   > 3. LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。
   > 4. ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。

8. fegin了解吗，手写过源码吗？

9. Dubbo服务暴露过程

   > - 首先将服务的实现封装成一个Invoker，Invoker中封装了服务的实现类。
   > - 将Invoker封装成Exporter，并缓存起来，缓存里使用Invoker的url作为key。
   > - 服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）

10. Dubbo的spi和jdk的什么区别

    > **是什么**
    >
    > SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件META-INF/services中，并由服务加载器读取配置文件，加载自定义实现类。这样可以在运行时，动态为接口替换实现类。因此，能够通过SPI机制扩展Dubbo组件。
    >
    > 比如，存在接口A，实现有A1, A2，A3
    >
    > 但是代码理不存在接口A，但是在使用时，会将接口A对应的实现方法配置在META-INF/services中，然后让工程依赖于提供的服务Jar，在提供运行时，使用接口A时，会去扫描依赖的Jar包，寻找实现了的A方法。
    >
    > **应用场景**
    >
    > 应用于插件扩展，新开发插件，接入到开源框架里，来扩展功能。
    >
    > 比如：Java中定义了JDBC接口，Java中并没有提供实际的实现类。在项目运行时，依据使用到的数据库类型，引入对应jar，如MySQL为mysql-jdbc-connector.jar。
    >
    > 比如：Dubbo中的协议扩展、负载均衡扩展、注册中心扩展等。

11. Rabbitmq和kafka区别

12. Kafka适合什么场景，项目中是什么场景

13. RabbitMQ如何保证消息不丢失

14. Zk满足了CAP哪些特性

15. redis和zk分布式锁设计，使用注意事项

16. 分布式如何保证一致性

17. 负载均衡算法实现

18. 轮询和随机的缺点

19. 如果redis作为分布式锁的时候，主节点挂掉了，但是数据还没有同步到从节点，这种情况怎么办

20. 加锁的时候什么时候选择本地锁，什么时候选择分布式锁？

21. RabbitMQ优缺点讲一下？

22. cap理论

23. rocketmq的消费模式

24. MQ用在业务场景？MQ本身的优势是什么？一般什么情况下可以使用这个技术？核心本质原因是什么呢？开线程做不就可以了区别是什么？

25. dubbo tcp如何实现高性能

    > 传输协议  dubbo
    >
    > 序列化协议  hession
    >
    > 通信框架  基于Netty  NIO  长连接
    >
    > 
    >
    > Dubbo主要内置了如下几种容错策略：
    >
    > - Failover(失败自动切换)（默认）
    >
    > 当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。Dubbo里默认配置的重试次数是2。
    >
    > - Failsafe(失败安全)
    >
    > 即使失败了也不会影响整个调用流程。当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。应用场景，可以用于写入审计日志等操作。
    >
    > - Failfast(快速失败)
    >
    > 失败立即报错，让调用方来决定下一步的操作并保证业务的幂等性。
    >
    > - Failback(失败自动恢复)
    >
    > Failback策略中，如果调用失败，则此次失败相当于`Failsafe`，将返回一个空结果。而与`Failsafe`不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。
    >
    > - Forking(并行调用)
    >
    > 一种典型的用成本换时间的思路。即第一次调用的时候就同时发起多个调用，只要其中一个调用成功，就认为成功。在资源充足，且对于失败的容忍度较低的场景下，可以采用此策略。
    >
    > - Broadcast(广播调用)
    >
    > 在某些场景下，可能需要对服务的所有提供者进行操作，此时可以使用广播调用策略。此策略会逐个调用所有提供者，只要任意有一个提供者出错，则认为此次调用出错。通常用于通知所有提供者更新缓存或日志等本地资源信息。

26. dubbo路由机制







## Netty

1. NIO 异步这些了解过吗 能不能说一下

2. netty线程模型

   > Netty 是采用 Reactor线程模型进行开发。
   >
   > 采用了 I/O 多路复用的方案，Reactor 模式作为其中的事件分发器，负责将读写事件分发给对应的读写事件处理者。
   >
   > 可以使用三种Reactor 模式：单线程模式、多线程模式、主从多线程模式。
   >
   > - 单线程模式
   >
   >   > Reactor 的单线程模型结构，在 Reactor 单线程模型中，所有 I/O 操作（包括连接建立、数据读写、事件分发等），都是由一个线程完成的。单线程模型逻辑简单，缺陷也十分明显：
   >   >
   >   > 1. 一个线程支持处理的连接数非常有限，CPU 很容易打满，性能方面有明显瓶颈；
   >   > 2. 当多个事件被同时触发时，只要有一个事件没有处理完，其他后面的事件就无法执行，这就会造成消息积压及请求超时；
   >   > 3. 线程在处理 I/O 事件时，Select 无法同时处理连接建立、事件分发等操作；
   >   > 4. 如果 I/O 线程一直处于满负荷状态，很可能造成服务端节点不可用。
   >
   >   Reactor 单线程模型所有 I/O 操作都由一个线程完成，所以只需要启动一个 EventLoopGroup 即可。
   >
   >   ```java
   >   EventLoopGroup group = new NioEventLoopGroup(1);
   >   ServerBootstrap b = new ServerBootstrap();
   >   b.group(group)
   >   ```
   >
   > - 多线程模式
   >
   >   >  Reactor 多线程模型将业务逻辑交给多个线程进行处理。除此之外，多线程模型其他的操作与单线程模型是类似的，例如读取数据依然保留了串行化的设计。当客户端有数据发送至服务端时，Select 会监听到可读事件，数据读取完毕后提交到业务线程池中并发处理。
   >
   >   NioEventLoopGroup 可以不需要任何参数，它默认会启动 2 倍 CPU 核数的线程。
   >
   >   ```java
   >   EventLoopGroup group = new NioEventLoopGroup();
   >   ServerBootstrap b = new ServerBootstrap();
   >   b.group(group)
   >   ```
   >
   > - 主从多线程模式
   >
   >   <img src="https://s0.lgstatic.com/i/image/M00/64/D5/CgqCHl-ZNDiAPgGOAAHx74H-t44265.png" alt="3.png" style="zoom:50%;" />
   >
   >   > 主从多线程模型由多个 Reactor 线程组成，每个 Reactor 线程都有独立的 Selector 对象。MainReactor 仅负责处理客户端连接的 Accept 事件，连接建立成功后将新创建的连接对象注册至 SubReactor。再由 SubReactor 分配线程池中的 I/O 线程与其连接绑定，它将负责连接生命周期内所有的 I/O 事件。
   >
   >   大多数场景下，我们采用的都是主从多线程 Reactor 模型。Boss 是主 Reactor，Worker 是从 Reactor。它们分别使用不同的 NioEventLoopGroup，主 Reactor 负责处理 Accept，然后把 Channel 注册到从 Reactor 上，从 Reactor 主要负责 Channel 生命周期内的所有 I/O 事件。
   >
   >   ```java
   >   EventLoopGroup bossGroup = new NioEventLoopGroup();
   >   EventLoopGroup workerGroup = new NioEventLoopGroup();
   >   ServerBootstrap b = new ServerBootstrap();
   >   b.group(bossGroup, workerGroup)
   >   ```
   >
   >   主从多线程模式甚至可以适当增加 SubReactor 线程的数量，从而利用多核能力提升系统的吞吐量。

3. 怎么解决粘包问题

   > 发送固定长度，不足使用空位补齐
   >
   > 使用特定分隔符
   >
   > 使用消息长度+消息内容
   >
   > Netty中封装了对应解码器，开箱即用

4. nio bio区别，nio底层epoll实现

5. Netty 核心组件有哪些？分别有什么作用？

   > - 网络通信层：
   >
   >   网络通信层的职责是执行网络 I/O 的操作。它支持多种网络协议和 I/O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。
   >
   >   网络通信层的核心组件包含BootStrap、ServerBootStrap、Channel三个组件。
   >
   >   BootStrap & ServerBootStrap
   >
   > - 事件调度层
   >
   >   事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件（ I/O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。
   >
   >   事件调度层的核心组件包括 EventLoopGroup、EventLoop。
   >
   > - 服务编排层
   >
   >   核心组件包括 ChannelPipeline、ChannelHandler、ChannelHandlerContext。
   >
   >   ChannelPipeline

6. EventloopGroup 了解么?和 EventLoop 啥关系?

   > Netty 中 EventLoop 可以理解为 Reactor 线程模型的事件处理引擎，每个 EventLoop 线程都维护一个 Selector 选择器和任务队列 taskQueue。它主要负责处理 I/O 事件、普通任务和定时任务。
   >
   > 1. 一个 EventLoopGroup 往往包含一个或者多个 EventLoop。EventLoop 用于处理 Channel 生命周期内的所有 I/O 事件，如 accept、connect、read、write 等 I/O 事件。
   > 2. EventLoop 同一时间会与一个线程绑定，每个 EventLoop 负责处理多个 Channel。
   > 3. 每新建一个 Channel，EventLoopGroup 会选择一个 EventLoop 与其绑定。该 Channel 在生命周期内都可以对 EventLoop 进行多次绑定和解绑。

7. Bootstrap 和 ServerBootstrap 了解么？

   > Bootstrap 是“引导”的意思，它主要负责整个 Netty 程序的启动、初始化、服务器连接等过程，
   >
   > Netty 中的引导器共分为两种类型：一个为用于客户端引导的 Bootstrap，另一个为用于服务端引导的 ServerBootStrap
   >
   > Bootstrap 和 ServerBootStrap 十分相似，两者非常重要的区别在于 Bootstrap 可用于连接远端服务器，只绑定一个 EventLoopGroup。而 ServerBootStrap 则用于服务端启动绑定本地端口，会绑定两个 EventLoopGroup，这两个 EventLoopGroup 通常称为 Boss 和 Worker（主从模式）。

8. NioEventLoopGroup 默认的构造函数会起多少线程？

   > 默认的构造函数实际会起的线程数为 CPU核心数\*2

9. Netty 服务端和客户端的启动过程了解么？

10. Netty 长连接、心跳机制了解么？

11. Netty内存管理是怎样的

12. Netty 的零拷贝了解么？

    > 只要能够减少不必要的 CPU 拷贝，都可以被称为零拷贝。
    >
    > Netty 中的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：
    >
    > - 堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。
    >
    >   如果在 JVM 内部执行 I/O 操作时，必须将数据拷贝到堆外内存，才能执行系统调用。
    >
    >   Netty 在进行 I/O 操作时都是使用的堆外内存，可以避免数据从 JVM 堆内存到堆外内存的拷贝。
    >
    > - CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。
    >
    > - 通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。
    >
    >   Unpooled.wrappedBuffer 方法可以将不同的数据源的一个或者多个数据包装成一个大的 ByteBuf 对象，其中数据源的类型包括 byte[]、ByteBuf、ByteBuffer。包装的过程中不会发生数据拷贝操作，包装后生成的 ByteBuf 对象和原始 ByteBuf 对象是共享底层的 byte 数组。
    >
    > - ByteBuf.slice 操作与 Unpooled.wrappedBuffer 相反，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。
    >
    > - Netty 使用 FileRegion 实现文件传输，FileRegion 底层封装了 FileChannel#transferTo() 方法，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝，这属于操作系统级别的零拷贝。

13. Netty 的 NioEventLoop 是如何实现的？它为什么能够保证 Channel 的操作是线程安全的？

14. Netty 如何解决 JDK epoll 空轮询 Bug？

15. NioEventLoop 是如何实现无锁化的？





## 消息队列

1. 消息队列---推拉模式--- mq丢失情况探究
2. 





## 数据库Redis

1. redis的string的底层实现

   > 底层实现没有采用C语言的字符串类型
   >
   > 定义了新的数据结构，SDS即*Simple Dynamic String* ，是一种动态字符串
   >
   > ```c
   > struct sdshdr{
   > int len;/*字符串长度*/
   > int free;/*未使用的字节长度*/
   > char buf[];/*保存字符串的字节数组*/
   > }
   > ```
   >
   > 
   >
   > - C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。
   > - 避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。
   > - 空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。
   > - 惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。
   > - 二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用'\0'标识字符串的结束，如果我们存储的字符串中间出现'\0'，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。
   >
   >  字符串最大为512M

2. redis分布式锁的底层lua setnx

   > 

3. Redis有哪5种数据类型，底层实现结构

   > String
   >
   > Map     
   >
   > List
   >
   > Set
   >
   > Sorted Set

4. Set、Zset分别用于哪些场景

   > Set 为无序集合、自动去重，可用于存储类似文章标签。Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能
   >
   > zset为有序集合，去重，用于排行榜，按点击率排名
   >
   > zet应用场景： 延时队列、排行榜（点击榜）
   >
   > [Redis ZSet 的几种使用场景](https://zhuanlan.zhihu.com/p/147912757)

5. Redis是怎么删除过期key的

   > 由于Redis是将数据存储在内存中，容量有限，需要尽可能存储热点数据
   >
   > 两种方式
   >
   > 定期删除，定时100ms，随机抽取设置了过期时间的key，删除已经过期了的数据
   >
   > 惰性删除，当请求指定key的数据，会先判断是否设置了过期时间，是否超时，如果数据已过期，将不会返回
   >
   > 采用两种方式结合
   >
   > 
   >
   > 同时，redis还有缓存淘汰策略
   >
   > 

6. Redis有哪些持久化方式

   > 有两种
   >
   > RDB  执行过命令后，会将内存中存储的数据定时存储到硬盘上，存储在dump.rdb文件中，通过定时N秒内有M个操作的方式触发存储，该种方式容易造成数据丢失
   >
   > AOF  命令执行过后，会将命令记录到文件中，恢复时，直接将执行过命令重新执行一次，即可恢复，当存储命令较多，重启时Redis启动较慢
   >
   > 两种方式各有优势
   >
   > Redis4.0 混合持久化，两种方式结合

7. Redis常用的应用场景

   > 1）利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力
   >
   > 2）利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码
   >
   > 3）利用setnx命令的特性，可以实现分布式锁

8. Redis缓存穿透是什么，如何解决？

   > 缓存穿透，是有大量缓存、数据库中不存在的请求，请求直接打到数据库上
   >
   > 解决方案
   >
   > 1. 加校验，对明显有误的请求参数，不下发处理
   > 2. 当请求不存在数据，返回时，同步到redis中，设置null值，并设置过期时间（时间不能过长）
   > 3. 使用布隆过滤器

9. Redis缓存雪崩

   > Redis能够抗住每秒1w请求，但是同时有20w访问量，导致Redis扛不住
   >
   > 解决方案
   >
   > 1. 增加多级缓存，本地缓存，先判断本地缓存是否存在，
   > 2. 使用Redis高可用集群模式，保证高可用，使用RDB+AOF持久化，保证挂掉后可以快速恢复
   > 3. 限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。

10. Redis击穿

    > 缓存击穿，热点数据大量同时失效，同时大量用户访问，请求全部打到数据库
    >
    > 解决方案
    >
    > 1. 设置热点数据永不过期，通过定时任务去定时更新
    > 2. 采用分布式锁，热点数据失效，为了避免同时大量请求直接都去查询数据库，此时需要加锁，查询一次数据库后，更新至缓存，其它在等待锁的请求，进来后先再查询一遍缓存，此时缓存里已存在，可以直接返回，不必查询数据库。

11. Redis分布式锁

12. 项目中缓存使用场景，双写一致性怎么保证的

    > **情景1**： 先更新数据库，然后再去删除缓存，但是删除缓存失败，导致两者数据不一致
    >
    > **解决** 先删除缓存，再去更新数据库。如果更新数据库失败，缓存中为空，不会造成数据不一致
    >
    > **情景2**：读写并发情况下对同一数据进行读写，更新数据时，先把缓存删除了，但是在更新数据库期间，还未完成，有请求过来，先请求缓存为空，然后去请求数据库，读取到旧值，又把旧值更新到了缓存中，会导致数据不一致
    >
    > **解决** 针对修改同一个数据请求操作，进行hash，划分到一个队列中，一个队列对应一个线程。同时，读取数据时，发现数据不在缓存中，也可将重新读取数据和更新缓存操作，发送到同一个队列中，此时一个线程处理该队列中操作，串行化执行。

13. redis zset实现，跳跃表实现 时间复杂度

    > Zset表示有序集合
    >
    > 有序集合对象的编码可以是`ziplist散列表`或者`skiplist跳跃表`。同时满足以下条件时使用ziplist编码：
    >
    > - 元素数量小于128个
    > - 所有member的长度都小于64字节
    >
    > 不能满足上面两个条件的使用 skiplist 编码
    >
    > 跳跃表，查找元素时，跳表能够提供O(logN)
    >
    > - 当数据较少时，sorted set是由一个ziplist来实现的。
    > - 当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。
    >
    > [redis zset底层实现原理](https://www.cnblogs.com/yuanfang0903/p/12165394.html)
    >
    > **总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：**
    >
    > - 分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。
    > - 在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。
    > - 第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。
    > - 在skiplist中可以很方便地计算出每个元素的排名(rank)。

14. 跳跃表的思想是怎样的？哪里有用到跳跃表

    > 通常链表时按照一个节点中存储指向下个节点的指针，每次只能指向一个数据
    >
    > 但是跳跃表，在一个节点中可以有多层，能够同时指向后面多个节点。
    >
    > 在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度
    >
    > skiplist中元素有序排列
    >
    > skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。

15. redis长度过长怎么优化？哪个api，数据量超过多少效率会变低？

    [Redis 单key值过大 优化方式](https://blog.csdn.net/beyond59241/article/details/78889867/)

16. redis使用过程中出现过变慢的情况吗？

    > 使用复杂度高的命令
    >
    > 存储大的key值，可能会变慢
    >
    > 大量key集中过期
    >
    > 实例内存达到上限
    >
    > 网卡负载过高
    >
    > [Redis为什么会变慢](https://www.cnblogs.com/zt007/p/13612263.html)
    >
    > 可以通过查询慢日志，进行查询哪些操作导致变慢
    >
    > 首先设置Redis的慢日志阈值，只有超过阈值的命令才会被记录，这里的单位是微秒，例如设置慢日志的阈值为5毫秒，同时设置只保留最近1000条慢日志记录：

17. Redis的并发和互斥怎么设计

    



## 数据库MySQL

1. mysql的索引，innodb的行锁的理解

   > 行锁，锁行
   >
   > 又分为共享锁和排它锁

2. mysql索引==== B+ 日志问题（3个）

3. innodb和myisam区别

   > MySQL核心在于插件式存储引擎，存储引擎是基于表，开发者可以按照自己意愿进行开发，不同存储引擎具备不同的特点，包含InnoDB、MyISAM等。
   >
   > - InnoDB存储引擎
   >
   > InnoDB支持事务，强制要求有主键，支持外键，高并发、大数据量（通过分库分表、读写分离），高可用（主备切换）。
   >
   > 现在版本（5.5.8开始）默认存储引擎为InnoDB，使用比较成熟，常用。
   >
   > - MyISAM存储引擎
   >
   > 不支持事务，不支持外键，支持全文索引，索引文件与数据文件分开，索引文件位于内存中，查询性能较好，适用于多查询的需求。
   >
   > 为表锁设计，并发写，性能差一些。
   >
   > 适用于报表系统，一次导入，后面都是大量查询场景。目前使用MyISAM的场景并不多

4. 如果由大量的增删操作，那么应该选择哪个存储引擎，为什么

   > 使用innoDB
   >
   > innoDB为行锁，InnoDB支持事务，强制要求有主键，大数据量（通过分库分表、读写分离），
   >
   > MyISAM为表锁，不支持事务，不支持外键，支持全文索引，索引文件与数据文件分开，索引文件位于内存中，查询性能较好，适用于多查询的需求。
   >
   > 为表锁设计，并发写，性能差一些。

5. myisam和innodb支持锁的粒度是怎样的

   > myisam  表锁
   >
   > InnoDB   行锁（共享锁、排他锁）
   >
   > 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般(使用于Berkeley DB引擎)

6. 索引都要怎么设计才能达到最优

   > 1）使用1-3个索引
   >
   > 2）主键使用自增主键
   >
   > 3）索引字段的选择，尽量使用数字型
   >
   > 4）需要使用该字段在表中能够有更多的不同值，避免多的重复值
   >
   > 5）注意联合索引的匹配规则

7. mysql连接池满怎么排查

   > 1.查看最大连接数配置（MySQL服务器允许的最大连接数16384）
   > show variables like '%max_connections%'
   >
   > 2.查看当前连接数     show full processlist
   >
   > 3.使用show status;查看Max_used_connections参数
   >
   > 如果当前连接数和连接数配置接近，说明连接数差不多满了。
   >
   > 
   >
   > **连接数多大多数都是空闲连接，为什么空闲连接没有释放呢**
   >
   > 应用使用长连接模式：对于长连接模式（比如Java应用），应用侧应该配置连接池。连接池的初始连接数设置过高，应用启动后建立多个到RDS实例空闲连接。
   >
   > **解决方法**
   >
   > 1）利用`show processlist`查看id，然后`kill id`即可
   >
   > 2）修改应用，长连接模式需要启用连接池的复用功能
   >
   > [MySQL 连接数满情况的处理](https://www.jianshu.com/p/6689474434f7)

8. 间隙锁如何实现，幻读问题是什么，它是怎么通过间隙锁解决的，for update能否锁表

9. 分库分表怎么设计

10. 水平分表依据什么分？时间还是数据

11. 分库分表之后我想查询近期的订单，怎么查

12. select count(*)时InnoDB和MylSAM分别是怎么处理的

    > 
    >
    > ![img](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbcpL4J5Glffibia7rnZT3e28j2xsC3PzoqCuPXiaz2YMR6WhGOT55BlprUib3T5GqQX0oMltaicCXdiblg/640?wx_fmt=png)
    >
    > 
    >
    > https://zhuanlan.zhihu.com/p/145181075

13. 聚簇索引和非聚簇索引的区别

    > B+树索引分为聚集索引和非聚集索引。
    >
    > **聚集索引**  InnoDB，数据文件就是索引文件，默认使用主键作为索引，称为聚簇索引。
    >
    > InnoDB中要求必须有主键
    >
    > 如果采用非主键值作为索引，此时索引中元素对应的value值为主键值，查找时，会先在对应非主键值的索引中，查找到元素对应的主键，然后再在数据文件的聚集索引中，查找到对应元素。
    >
    > 因此，一般InnoDB中，都建议采用自增值作为主键。自增值，在插入元素时，只需要顺序插入新节点，避免了树的旋转再进行拆分页。
    >
    > **非聚集索引** MyISAM，数据文件与索引文件分开。索引文件中存储的值为对应数据文件中的地址。

    

14. 事务有哪些隔离级别，分别解决了什么问题

    > **读未提交（read-uncommitted）**：一个事务可以读取到另一个事务里未提交的数据
    >
    > **读已提交（也称不可重复读）（read-committed）**：一个事务在读取另一个事务里修改到的数据，需要等到另一个事务将数据修改提交后，才能读取到。例如：事务A读取到表中某个数据值为A，当事务B对该数据进行修改，修改为B，此时再提交，那么事务A再读取该数据，得到的值为B，即能够读取到其它事务已提交的数据，不能读取到未提交的数据。相对于读未提交，稍显严格一点。（能够解决脏读）
    >
    > **可重复读（repeatable-read）**：一个事务开始后，读取某个数据值为A，无论读取多少次都为A，即使其它事务对该值进行了修改，无论修改是否提交。（能够解决不可重复读）
    >
    > **串行化（serializable）**：多个事务执行，串行化执行，一个事务执行，需要等到上个事务执行完成，才能执行，不能并行执行。（能够解决幻读）
    >
    > 事务的执行存在脏读、不可重复读和幻读的问题。
    >
    > **脏读**：事务A读取到了另一个事务B里修改的值，未提交，最终事务B回滚了，导致事务A读取到数据为脏数据
    >
    > **不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致
    >
    > **幻读**：针对插入，一个事务A将表中所有行的某个字段修改为A，此时另一个事务B插入了一条数据并提交，数据中的某个字段并没有被修改过。导致事务A的执行出现了幻觉，修改不完全。
    >
    > 
    >
    > 不同事务隔离级别能够解决的问题
    >
    > | 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
    > | :--------------------------- | ---- | ---------- | ---- |
    > | 读未提交（read-uncommitted） | 是   | 是         | 是   |
    > | 不可重复读（read-committed） | 否   | 是         | 是   |
    > | 可重复读（repeatable-read）  | 否   | 否         | 是   |
    > | 串行化（serializable）       | 否   | 否         | 否   |
    >
    > InnoDB存储引擎，默认事务隔离级别为可重复读（repeatable-read）。

15. 可重复读是怎么解决脏读的

    > **脏读**：事务A读取到了另一个事务B里修改的值，未提交，最终事务B回滚了，导致事务A读取到数据为脏数据
    >
    > **可重复读（repeatable-read）**：一个事务开始后，读取某个数据值为A，无论读取多少次都为A，即使其它事务对该值进行了修改，无论修改是否提交。（能够解决不可重复读）
    >
    > 

16. 有俩事务，事务A：读、写(张三)、读  事务B：读、写(李四)、读，假如俩事务同时执行，结果如何

    > 看是哪种事务级别

17. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？

    > 某字段为 varchar 字符串类型，传入参数值为 int 数字类型，发现查询的结果和预期的不一致。
    >
    >  如： 某两列 name='11' , name = '11aa' 。 where name = 11 ， 可以查到 '11' 和 '11aa' 两个结果，这里是错误的；而 where name ='11' ，能得到预期结果。
    >
    > 
    >
    > 某字段类型是 int 数字类型，传入参数为 varchar 字符串类型。查询到结果与预期不一致。
    >
    > 此时会进行截取。若字符串是以数字开头，且全部都是数字，则转换为数字结果是整个字符串；部分是数字，则转换为数字结果是截止到第一个不是数字的字符为止。 理解： varchar str = "123dafa"，转换为数字是123 。 SELECT '123dafa'+1 ; --- 124 。
    >
    > 
    >
    > 原因：
    >
    > 当MySQL字段类型和传入条件数据类型不一致时，会进行隐形的数据类型转换。
    >
    > 转换规则
    >
    > 2、若字符串是以数字开头，且全部都是数字，则转换为数字结果是整个字符串；部分是数字，则转换为数字结果是截止到第一个不是数字的字符为止。 理解： varchar str = "123dafa"，转换为数字是123 。 SELECT '123dafa'+1 ; --- 124 。
    >
    > 3、若字符串不是以数字开头，则转换为数字结果是 0 。 varchar str = "aabb33" ; 转换为数字是 0 。 SELECT 'aabb33'+100 ; --- 100 。
    >
    > 建议
    >
    > 对于 delete , update 等操作时，建议先使用 select 语句，看看获取的结果和预期的是否一致，再进行操作，相对会更安全一些。
    >
    > https://blog.csdn.net/HaHa_Sir/article/details/93666147

18. 有一个表存在字段id（非主键、递增可重复）、name，如果有1000W条数据，查其中一条，有索引和没索引的情况下执行时间，建索引是否有用、会走索引吗、为什么

    > 

19. 说说MySQL索引为什么用B+树呢，b树，红黑树呢？为什么不用

    > **B+树的优势：**
    >
    > 1.单一节点存储更多的元素，使得查询的IO次数更少。
    >
    > 2.所有查询都要查找到叶子节点，查询性能稳定。
    >
    > 3.所有叶子节点形成有序链表，便于范围查询。
    >
    > **二叉平衡树**
    >
    > AVL树是高度平衡的而二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 通常AVL树是在二叉搜索树上，经过局部调整而建立的，因此，它还是一棵排序树。

20. MySql调优

    > **数据选型：**首先是数据选型方面进行优化，选取最适用的字段属性，数据的表越小，查询越快 
    >
    > **范式应用：**合理使用范式和反范式 
    >
    > **存储引擎的选择：**如果该数据库读操作较多，存储引擎选择MyISAM，如果是写操作多，选择innodb 
    >
    > **主键选择：**代理主键 
    >
    > **执行计划explain：**使用explain+sql测试sql语句执行情况，然后优化sql语句 
    >
    > 1.  注意的关键字：type关键字，通常达到range级别，最好是ref，而ref最好是一个常数。 
    >
    >  **索引优化：** 
    >
    > 1.  尽量在主键上添加使用索引 
    > 2.  利用覆盖索引、索引下推机制，注意组合索引的匹配原则， 
    > 3.  尽量使用唯一索引，避免使用普通索引 
    >
    > **查询优化：**这个应该被包含在执行计划中，但是个人觉得还是拆出来，其实我们在写的时候就该注意sql的效率，explain执行计划只是验证 
    >
    > 1.  优化数据访问，避免查询中出现筛选大量数据，可以通过limit限制； 
    > 2.  避免select * from table这种全表扫描的语句 
    > 3.  如果业务没有特殊规定数据，那么就尽量避免使用UNION，可以考虑UNION-ALL替换，因为后者不会过滤重复数据，效率高于UNION

21. 索引失效场景有哪些

    > 1）不符合组合索引的规则
    >
    > 2）使用like %XXXX，通配符在前
    >
    > 3）查询条件使用函数计算的时候
    >
    > 4）使用NOT IN
    >
    > 5）类型转换的时候失效
    >
    > 6）or的左右两边的字段只有左边是有索引的，右边没有索引，这个时候查看执行计划。

22. mysql 幻读和间隙锁 分片实现事务

    > **间隙锁**
    >
    > 幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。锁的就是两个值之间的空隙。
    >
    > 在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的。
    >
    > 
    >
    > 间隙锁是在可重复读隔离级别下才会生效的
    >
    > 当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。
    >
    > 没有建立索引或者是非唯一索引时，则语句会产生间隙锁。
    >
    > **间隙的范围**
    >
    > 根据检索条件向下寻找最靠近检索条件的记录值A作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。

23. mysql原生实现分布式事务

24. 分库分表是以什么维度来划分的？划分的算法是怎样的，会不会出现数据分配不均衡的情况。

25. 事务的ACID，每一项是如何保证的

    > 原子性、一致性和持久性由事务的redo 日志和undo 日志来保证。
    >
    > undo log
    >
    > undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子，而redo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。
    >
    > 
    >
    > **原子性**
    >
    > 一个事务内的所有SQL操作是一个整体。都执行成功才算整个事务成功。如果某个失败，则必须要会退到事务执行之前的状态，执行成功的SQL需要被撤销。
    >
    > 失败回滚使用undo log保证
    >
    > 
    >
    > **一致性**
    >
    > 指数据一致性，执行事务是对数据库状态从一种状态转变为另一种状态，不能在执行事务前后，数据库完整性出现变化。比如，事务对数据表中的主键ID进行修改，事务执行成功或者回滚后，主键ID被修改，不再唯一，导致数据库状态发生变化。
    >
    > 通过undo log进行保证，undo会记录事务发生前后数据的变化，进行恢复
    >
    > 
    >
    > **Duration持久性**
    >
    > 一旦事务提交，其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。这个duration指的是mysql服务器可以重启的情况下，crash掉之后（比如说只写到pool buffer中，还没有fsync到磁盘文件中），保证duration。而不是物理损坏，物理损坏由备份来负责的
    >
    > 如何保证：
    >
    > 是通过redo来保证的。大部分情况下 Redo是物理日志，记录的是数据页的物理变化。
    >
    > Redo log可以简单分为以下两个部分：
    >
    > - 一是内存中重做日志缓冲 (redo log buffer),是易失的，在内存中
    > - 二是重做日志文件 (redo log file)，是持久的，保存在磁盘中
    >
    > **隔离性**
    >
    > 采用锁保证

26. SQL查询优化怎么做

    > [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)
    >
    > 0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
    >
    > 1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
    >
    > 2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
    >
    > 3.order by limit 形式的sql语句让排序的表优先查
    >
    > 4.了解业务方使用场景
    >
    > 5.加索引时参照建索引的几大原则
    >
    > 6.观察结果，不符合预期继续从0分析

27. MySQL 如何分析一条语句的执行过程。delete from t1 limit 3和delete from t1的区别？

28. 什么是幻读以及mysql如何避免幻读

    > **幻读**：针对插入，一个事务A将表中所有行的某个字段修改为A，此时另一个事务B插入了一条数据并提交，数据中的某个字段并没有被修改过。导致事务A的执行出现了幻觉，修改不完全。
    >
    > **串行化（serializable）**：多个事务执行，串行化执行，一个事务执行，需要等到上个事务执行完成，才能执行，不能并行执行。（能够解决幻读）
    >
    > 事务的执行存在脏读、不可重复读和幻读的问题。

29. 什么是间隙锁，在什么隔离级别以及什么情况下触发

    > **间隙锁**
    >
    > 幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。锁的就是两个值之间的空隙。
    >
    > 在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的。
    >
    > 
    >
    > 间隙锁是在可重复读隔离级别下才会生效的
    >
    > 当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。
    >
    > 没有建立索引或者是非唯一索引时，则语句会产生间隙锁。
    >
    > **间隙的范围**
    >
    > 根据检索条件向下寻找最靠近检索条件的记录值A作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。
    >
    > 

30. 索引B+树的优势在哪里

    > B+树是B树的优化，是一种多路查找树
    >
    > B+树索引中对应节点存入的元素都在叶子节点上，即内部节点25,50,75只存储索引key，不存储元素值data。同时在叶子节点上，加了顺序访问指针，便于范围查找。B+树总会保持平衡，因此在插入元素时，会进行拆分页。
    >
    > **B+树的优势：**
    >
    > 1.单一节点存储更多的元素，使得查询的IO次数更少。
    >
    > 2.所有查询都要查找到叶子节点，查询性能稳定。
    >
    > 3.所有叶子节点形成有序链表，便于范围查询。

31. MySQL引擎有哪些？各有什么区别、优势，并且底层是怎么实现的

    > InnoDB
    >
    > myisam

32. 怎么判断sql索引是否生效

    > 采用执行计划，explain
    >
    > explain select id , name from table where id=1
    >
    > 查看key字段
    >
    > | **字段**                                    | **说明**                                                     |
    > | ------------------------------------------- | ------------------------------------------------------------ |
    > | *table*                                     | *显示这一行的数据是关于哪张表的*                             |
    > | type                                        | 显示连接使用了何种类型,从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL |
    > | possible_keys                               | 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 |
    > | key                                         | 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 |
    > | key_len                                     | 使用的索引的长度。在不损失精确性的情况下，长度越短越好       |
    > | ref                                         | 显示索引的哪一列被使用了，如果可能的话，是一个常数           |
    > | rows                                        | MYSQL认为必须检查的用来返回请求数据的行数                    |
    > | Extra                                       | 关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢 |
    > | extra                                       | 列返回的描述的意义                                           |
    > | Distinct                                    | 一旦MYSQL找到了与行相联合匹配的行，就不再搜索了              |
    > | Not exists                                  | MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了 |
    > | ange checked for each Record（index map:#） | 没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 |

33. 如何分析SQL，执行计划的参数解释，type一般到什么级别合理？

    > 类型分类
    >
    > system>const>eq_ref>ref>range>index>ALL
    >
    > 越往左边，性能越高，比如system就比ALL类型性能要高出许多，其中system、const只是理想类型，基本达不到；
    >
    > 实际能优化到ref>range这两个类型，就是你自己写SQL，如果你没优化基本上就是ALL，如果你优化了，那就尽量达到ref>range这两个级别；
    >
    > 要对type优化的前提是，你需要有索引，如果你连索引都没有创建，那你就不用优化了，肯定是ALL
    >
    > 参考
    >
    > https://blog.csdn.net/ssspk_/article/details/89422085

    

34. MySQL数据丢失，怎么恢复，具体怎么操作

    

35. 用过哪些MySQL函数

    https://blog.csdn.net/weixin_42306509/article/details/106683298







## 网络

1. TCP滑动窗口

   > 滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。

2. 三次握手的作用？过程？状态改变？

   > 三次握手作用
   >
   > 客户端向服务端发起TCP connect连接时，会进行三次握手
   >
   > 通过三次握手作用，为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换`TCP窗口大小`信息
   >
   > 三次握手流程
   >
   > 第一次，客户端向服务端发起，携带SYN =1，初始序列seq=x，不能携带数据，客户端处于 `SYN_SEND` 状态
   >
   > 第二次，服务断接收到数据，携带SYN=1 ACK=1，初始序列seq=y，ack=x+1，不能携带数据，服务器处于 `SYN_RCVD` 的状态
   >
   > （证明客户端发送数据正常，服务端接收数据正常）
   >
   > 第三次，客户端接收到数据，进行响应，发送ACK=1，seq=x+1，ack=y+1，可以携带数据，服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接
   >
   > （证明客户端接收数据正常，服务端发送数据正常）
   >
   > ![三次握手.png](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28a45bd19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   >
   > 参考 
   >
   > https://juejin.cn/post/6844903958624878606

3. 为什么需要三次握手，两次不行吗

   > 三次握手的作用是为了确认双方的接收能力和发送能力是否正常
   >
   > 如果只有第一次，第二次，无法证明客户端的接受能力正常

4. http四次挥手，作用和过程是什么？

   > 作用，终止连接
   >
   > TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作
   >
   > 四次挥手过程
   >
   > 以客户端发起为例
   >
   > 第一步：客户端发送一个 FIN 报文，报文中会指定一个序列号。客户端处于`FIN_WAIT1` 状态。即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认
   >
   > 第二步：服务端收到FIN报文，回复确认报文（（ACK=1，确认号ack=u+1，序号seq=v），处于`CLOSE_WAIT`（关闭等待） 状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
   >
   > 第三步：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
   >
   > 第四步：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
   >
   > ![image.png](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28b49f652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   >
   > 参考 
   >
   > https://juejin.cn/post/6844903958624878606

5. 挥手为什么需要四次？

   > 在客服端第1次挥手时，服务端可能还在发送数据。
   >
   > 所以第2次挥手和第3次挥手不能合并。
   >
   > 
   >
   > 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

6. 2MSL等待状态指什么？

   > 在接收到第3次挥手后，会先进入TIME_WAIT（时间等待）状态，此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
   >
   > TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
   >
   > 
   >
   > 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

7. 四次挥手释放连接时，等待2MSL的意义?

   > **MSL**是Maximum Segment Lifetime的英文缩写，可译为“报文最大生存时间”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
   >
   > 
   >
   > **MSL为2分钟**，实际应用中常用的是30秒，1分钟和2分钟等
   >
   > centos7下默认是60秒
   >
   > [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_fin_timeout
   > 60
   >
   > 
   >
   > 服务端发送第三次挥手时处于LAST_ACK状态，客户端接受到第三次后，需要进行确认，发送ACK。
   >
   > 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为**这个ACK有可能丢失**，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。
   >
   > 服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
   >
   > 2. 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
   >
   > 目的就是为了完成正常的关闭。
   >
   > 

8. 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

   > 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

9. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

   > TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
   >
   > 

10. TCP/IP四层协议、ip在哪层

    > 应用层  http  TFTP  SMTP   （数据）
    >
    > 传输层  tcp/udp   （TCP包）
    >
    > 网络层  IP  ICMP     （IP包）
    >
    > 数据链路层    ARP 
    >
    > 物理层 

11. 输入url到页面加载完中间的流程

12. 线上用户出现502错误你怎么排查

    > 502错误，网关错误，后端服务器tomcat没有起来，应用服务的问题
    >
    > 一般指Nginx做反向代理服务器时，所连接的Web应用服务器无响应导致的。一般是因为后端的Tomcat，Jetty，Tornado等服务器没有启动。我们知道，Nginx属于HTTP服务器，不属于Web应用服务器。

13. http常见状态码

    > |      |           |                                                              |
    > | ---- | --------- | ------------------------------------------------------------ |
    > | 403  | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
    > | 404  | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
    >
    > [HTTP状态码](https://www.runoob.com/http/http-status-codes.html)

14. TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些

    > UDP
    >
    > 1) 面向无连接，无需先建立连接后再发送
    >
    > 2) 不可靠，当报文发送之后，是无法得知其是否安全完整到达的。
    >
    > 3)支持一对多，一对一，多对一和多对多交互通信
    >
    > |              | UDP                                                          | TCP                                    |
    > | :----------- | :----------------------------------------------------------- | -------------------------------------- |
    > | 是否连接     | 无连接                                                       | 面向连接                               |
    > | 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制                         | 可靠传输，使用流量控制和拥塞控制       |
    > | 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信                   | 只能是一对一通信                       |
    > | 传输方式     | 面向报文                                                     | 面向字节流                             |
    > | 首部开销     | 首部开销小，仅8字节                                          | 首部最小20字节，最大60字节             |
    > | 适用场景     | 高速传输和实时性要求高的通信广播通信。适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的情况，例如文件传输 |
    >
    > [一文搞懂TCP与UDP的区别](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)
    >
    > TCP最大的特点就是可靠传输：
    > 1.应答机制：对方收到消息底层会回复
    >
    > 2.超时重传：给多方发送一个数据，如果一段时间内对方没有接收，会隔一段时间给对方再次发送，如果一直没有回复，会认为对方掉线了
    >
    > 3.错误校验：如果接收的数据包序号发生了错乱，TCP会自动排序，保证数据的有序性，如果有重复数据包，会删除重复的数据包
    >
    > 4.流量控制：数据发送在网卡缓存区达到一定上限，对方不会一直发送数据，需要等待对方接收数据，网卡缓存区有空间再发送，保证网卡缓存不会超出

15. 301和302有什么区别

    > |      |                   |                                                              |
    > | ---- | ----------------- | ------------------------------------------------------------ |
    > | 301  | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
    > | 302  | Found             | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
    >
    > 共同点
    >
    > 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）
    >
    > 不同点
    >
    > - 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址**；
    > - 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址**。
    >
    > 场景
    >
    > - 场景一 想换个域名，旧的域名不用啦，这样用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
    > - 场景二 登录后重定向到指定的页面，这种场景比较常见就是登录成功跳转到具体的系统页面。
    > - 场景三 有时候需要自动刷新页面，比如5秒后回到订单详细页面之类。
    > - 场景四 有时系统进行升级或者切换某些功能时，需要临时更换地址。
    > - 场景五 像微博之类的使用短域名，用户浏览后需要重定向到真实的地址之类。

16. 403和404区别

    > |      |              |                                                              |
    > | ---- | ------------ | ------------------------------------------------------------ |
    > | 401  | Unauthorized | 请求要求用户的身份认证                                       |
    > | 403  | Forbidden    | 服务器理解请求客户端的请求，但是拒绝执行此请求（）           |
    > | 404  | Not Found    | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
    >
    > 403
    >
    > 服务器端接收到了请求，但是拒绝执行客户端的请求
    >
    > 403.4  规定使用https访问
    >
    > 404 
    >
    > 场景：前端请求后端不存在的接口，资源

17. 504和500有什么区别

    > |      |                            |                                                              |
    > | ---- | -------------------------- | ------------------------------------------------------------ |
    > | 500  | Internal Server Error      | 服务器内部错误，无法完成请求                                 |
    > | 501  | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |
    > | 502  | Bad Gateway                | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
    > | 503  | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
    > | 504  | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
    > | 505  | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理               |
    >
    > 504错误，代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。
    >
    > 出现：nginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。
    >
    > 解决：不同电脑之间的IP数据传输的流通状况。修改Nginx配置参数，可以调大nginx超时限制，
    >
    > fastcgi_connect_timeout
    > fastcgi连接超时时间，默认60秒
    >
    > fastcgi_send_timeout
    > nginx 进程向 fastcgi 进程发送请求过程的超时时间，默认值60秒
    >
    > fastcgi_read_timeout
    > fastcgi 进程向 nginx 进程发送输出过程的超时时间，默认值60秒
    >
    > 
    >
    > 502错误，网关错误，后端服务器tomcat没有起来，应用服务的问题
    >
    > 一般指Nginx做反向代理服务器时，所连接的Web应用服务器无响应导致的。一般是因为后端的Tomcat，Jetty，Tornado等服务器没有启动。我们知道，Nginx属于HTTP服务器，不属于Web应用服务器。
    >
    > 

18. HTTPS 和 HTTP 有什么区别

    > HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。因此，HTTP协议不适合传输一些敏感信息。
    >
    > HTTPS协议是在HTTP下加入SSL层，一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
    >
    > https与http区别
    >
    > 　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    >
    > 　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    >
    > 　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    >
    > 　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
    >
    > 
    >
    > https加密方式
    >
    > HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密
    >
    > SSL（Secure Socket Layer，安全套接字层）	（SSL时SLS的前身）
    >
    > ![img](https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif)
    >
    > 1. 首先，浏览器请求一个url，找到服务器，向服务器发起一个请求。服务器将自己的证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息返回客户端。
    > 2. 浏览器检查CA证书是不是由可以信赖的CA机构颁发的，确认证书有效和此证书是此网站的。如果不是，给客户端发一个警告，询问是否继续访问。
    > 3. 如果是，客户端使用公钥加密了一个随机对称密钥，包括加密的URL一起发送到服务器
    > 4. 服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。
    > 5. 服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页了。

19. HTTPS采用哪种加密方式

    > 对称加密和非对称加密
    >
    > 对称加密就是加密和解密用的是同一个密钥k。
    > 非对称加密是发送端使用公开的公钥a加密，然后接收端使用私密的私钥b解密。
    >
    > HTTPS两种都用了
    >
    > **使用非对称加密传输一个对称密钥K**，让服务器和客户端都得知。然后两边都**使用这个对称密钥K来加密解密收发数据**。因为**传输密钥K是用非对称加密方式**，很难破解比较安全。而**具体传输数据则是用对称加密方式**，加快传输速度。两全其美。
    >
    > 
    >
    > [https中的对称加密和非对称加密](https://www.jianshu.com/p/918d9f517749)
    >
    > 
    >
    > HTTPS的缺点
    >
    > - HTTPS协议多次握手，导致页面的加载时间延长近50%；
    > - HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
    > - 申请SSL证书需要钱，功能越强大的证书费用越高。
    > - SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

20. http 1.0 1.1 2.0区别？

    > http1.0 2.0区别
    >
    > 1. 二进制协议，HTTP/1.1 版的头信息肯定是文本，HTTP/2 则是二进制协议，解析起来更高效
    > 2. 多路复用，HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
    > 3. 数据压缩，HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
    > 4. 服务器推送，对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。
    
    
    
21. http缓存

    > 是什么
    >
    > HTTP 缓存机制就是，配置服务器响应头来告诉浏览器是否应该缓存资源、是否强制校验缓存、缓存多长时间；浏览器非首次请求根据响应头是否应该取缓存、缓存过期发送请求头验证缓存是否可用还是重新获取资源的过程。
    >
    > | 响应头        | (常用)值                                                     | 说明                                               |
    > | ------------- | ------------------------------------------------------------ | -------------------------------------------------- |
    > | Cache-Control | no-cache, no-store, must-revalidate, max-age, public, private | 控制浏览器是否可以缓存资源、强制缓存校验、缓存时间 |
    > | ETag          | 文件指纹（hash码、时间戳等可以标识文件是否更新）             | 强校验，根据文件内容生成精确                       |
    > | Last-Modified | 请求的资源最近更新时间                                       | 弱校验， 根据文件修改时间，可能内容未变，不精确    |
    > | Expires       | 资源缓存过期时间                                             | 与响应头中的 Date 对比                             |
    >
    > 参考
    >
    > https://blog.csdn.net/guduyibeizi/article/details/81814577



## 场景题

1. 春晚红包提现流程-----如果保证高并发可用？

   > 数据落库 --> 专门增加一层服务用来分发请求 ----> 后面服务进行排队处理。 最终增加第三方表来做幂等（1分库分表不容易扫表，数据分散，2该表比较容易聚合，3放在其他服务上，保证可用性） 
   >
   > 这个就是大并发下的最终一致性问题了，就是保证每个人都能正常提现，且能够正常到账。当时的提出了这样一个思路，核心点利用MQ进行串行化处理，然后让每一步的数据都可追溯，最终发钱的时候，做最终校验。

2. 设计一个缓存，在springboot启动时就加载好，你会怎么设计，把相应要用到的注解和类方法都描述一下

3. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发

4. Redis也扛不住了，万级流量会打到DB上，该怎么处理

5. 并发量很大，服务器宕机。你会怎么做

6. 一个url对应一个random值，要求设计一个系统，根据url查询random值，具体到表怎么设计，索引怎么加，代码怎么写？

7. 我有8件事要做，最要要同意返回处理结果，每件事要进行异步的方式去做。你怎么完成这个需求

8. 使用redis记录当日用户数量

9. mysql的一个场景，客户端按顺序先后发生 读，读，写，这三个操作指令，mysql怎么保证这三指令数据一致性（数据按顺序操作）





## 算法

1. 两个排序数组中找第k大的数 （面试官强烈要求你用二分法，难度hard）

   > [参考](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)

2. LRU实现，从O(n)到O(1)的各种方案，最理想的情况是什么

3. 最小覆盖子串

   > 

4. 如何判断一个链表是环链

   > https://leetcode-cn.com/problems/linked-list-cycle/submissions/

5. 二叉树遍历，递归，非递归，层次遍历

6. 判断图中形成环 优先队列的删除节点方式

7. 两个数组如何找交集

   > https://leetcode-cn.com/problems/intersection-of-two-arrays/

8. 输入一行字符串
   找到里面最大的那个在后面加上(max)
   如果有多个就在每个后面都加上
   最后输出
   两次循环一次找最大
   第二次在每个最大后面加max

9. 最长回文串

   https://leetcode-cn.com/problems/longest-palindromic-substring/

10. 排序算法你知道那些？快速排序平均时间复杂度和最差时间复杂度。partition过程中最差情况是什么样的，描述一下

12.二分查找

13. 反转链表

    https://leetcode-cn.com/problems/reverse-linked-list/

14. 删除二叉搜索树的某一个节点

15. 给定数组，求第k大的数字

    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

16. 求递增数组中相加等于10的元素对

17. 数组从下标最大的删与最小的删有什么区别

18. 合并两个有序的数组

    https://leetcode-cn.com/problems/merge-sorted-array/

19. 最长只有一种字符的字符串

20. [2个栈实现队列](https://www.nowcoder.com/jump/super-jump/practice?questionId=23281)

21. [合并有序链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=682)

    https://leetcode-cn.com/problems/merge-two-sorted-lists/

22. [是否回文链表](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008769)

23. 快排

    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

24. M*N 横向纵向均递增的矩阵找指定数

25. [两个排序数组找中位数](https://www.nowcoder.com/jump/super-jump/practice?questionId=1008512)

26. [跳台阶](https://www.nowcoder.com/jump/super-jump/practice?questionId=23261)

27. 链表数字相加

28. [岛屿数量](https://www.nowcoder.com/jump/super-jump/word?word=岛屿数量)

    https://leetcode-cn.com/problems/number-of-islands/submissions/

29. 合并两个有序链表

    https://leetcode-cn.com/problems/merge-two-sorted-lists/

    



需要过的题目

https://www.nowcoder.com/discuss/594301



## 设计模式

1. 单例模式
2. 策略模式
3. 装饰器模式
4. 适配器模式
5. 工厂模式



## Linux

1. 查看 CPU 的命令和磁盘 IO 的命令





## 其它

1. 你有遇到什么样的技术难题？
2. 有了解过领域模型相关知识？
3. 项目中最大的亮点，或者说项目中最大的难题是怎么解决的？

4. 日志大数据处理桶排序

## 参考

[面试题](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485351&idx=2&sn=214225ab4345f4d9c562900cb42a52ba&chksm=e80db1d1df7a38c741137246bf020a5f8970f74cd03530ccc4cb2258c1ced68e66e600e9e059&scene=21#wechat_redirect)



## 来源

[社招两年，快手，虾皮阿里面经](https://www.nowcoder.com/discuss/593969)

[发个已经跪了的阿里一面，大概40分钟左右](https://www.nowcoder.com/discuss/593710)

[字节跳动1年半经验（双非非科班）一面面经](https://www.nowcoder.com/discuss/593554)

[顺丰后端社招面经](https://www.nowcoder.com/discuss/experience?tagId=639&order=3&companyId=0&phaseId=3)

[北京天润融通科技Java社招面经](https://www.nowcoder.com/discuss/591855)

[sap 上海 java 社招](https://www.nowcoder.com/discuss/588635)

[秋招社招经验(2020.12)](https://www.nowcoder.com/discuss/585741)

[携程社招Java二面面经](https://www.nowcoder.com/discuss/584725)

[社招-携程Java初面面经](https://www.nowcoder.com/discuss/584451)

[腾讯Java工程师社招面试经历](https://www.nowcoder.com/discuss/583626)

[腾讯Java社招面试经历记录](https://www.nowcoder.com/discuss/583601)

[小米社招Java岗一二面](https://www.nowcoder.com/discuss/583517?source_id=discuss_experience_nctrack&channel=-1)

[京东Java社招面试经历分享](https://www.nowcoder.com/discuss/583437?source_id=discuss_experience_nctrack&channel=-1)

[oppo社招Java面试经历分享](https://www.nowcoder.com/discuss/581405?source_id=discuss_experience_nctrack&channel=-1)

[字节跳动后端社招面试分享](https://www.nowcoder.com/discuss/578918?source_id=discuss_experience_nctrack&channel=-1)

[PingCAP后端社招面试经历](https://www.nowcoder.com/discuss/578850?source_id=discuss_experience_nctrack&channel=-1)

[1.3年工作经验，双非裸辞社招面经](https://www.nowcoder.com/discuss/578614?source_id=discuss_experience_nctrack&channel=-1)

[腾讯Java社招面经分享](https://www.nowcoder.com/discuss/578277?source_id=discuss_experience_nctrack&channel=-1)












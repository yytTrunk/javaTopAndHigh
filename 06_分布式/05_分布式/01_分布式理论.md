# 分布式

## 一 接口幂等性

**是什么**

接口可重复调用，在调用多次情况下，接口最终得到结果是一致的。

**常用解决方案**

- 全局唯一ID

- 去重表

- 状态机



## 二 分布式Session

spring-session 共享session至redis中，实现多个部署实例中session一致



## 三 采用zookeeper两级缓存，保持一致性

redis

JVM缓存，（使用zookeeper保持一致性）

可应用于电商项目中秒杀库存的判断



## 四 消息队列异步处理

消息队列异步下单后，可通过前端轮询后端接口从缓存中读取结果

**如何确保用户只能下单一次**

需要考虑重复下单，可通过第一次下单添加排队标记，将下单结果添加到redis缓存，完成后删除下单排队标记，第二次进入后，从下单结果缓存中，读取到是否已存在，若查询存在会返回提示已下单过。

重复多次，都会先从缓存中读取判断，采用分布式锁。





## 五 流量削峰，限流防刷

**防刷**

1. 点击时，页面增加验证码

2. 下单接口地址隐藏，防止通过调接口直接刷

   生成一次性token存入缓存，前端获取token，调用接口必须携带token，后端先从缓存读取token，进行比较

**限流**

1. nginx限流
2. 限流接口，使用redis的原子计数器incr，有一个请求时就加1，然后计数统计，设置超时时间。比如1分钟，请求超过1万次，就报错，



## 六 应用层页面缓存与模板动态渲染

1. nginx+lua，使用openresty

使用lua脚本，先从nginx本地缓存拿需要填充到页面的数据，如果拿不到再从后端接口去拿，再在nginx的本地缓存里存放一份，然后使用openresty渲染html模板。下次再访问直接从nginx缓存中拿

**应用** 可用于上商品详情页渲染，动态模块渲染

此处一般不需要使用后端去更新nginx本地缓存，设置超时时间即可，因为这些数据通常不修改



## 七 缓存失效、缓存击穿、缓存雪崩

- #### 缓存失效

由于大量缓存失效，同时大量用户访问，

**解决** 可以通过将缓存失效时间设置为范围内的随机数，避免同时大量请求缓存失效

- #### 缓存击穿

采用不存在数据的请求，大量访问，直接穿透一级、二级缓存，去访问数据库，导致缓存失去意义

**解决**  布隆过滤器或者对于不存在的数据的请求在redis中存放null值

- #### 缓存雪崩

并发请求过多，redis无法响应请求，挂掉，大量请求直接访问到数据库（比如20w请求，redis能够支持1w，剩余直接去请求数据库）

**解决** 采用redis集群更高可用或者多级缓存或者限流



## 八 分布式事务

### 8.1 分布式事务指什么

分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。

例如在下单场景下，支付订单和减库存如果不在同一个节点上，提交时就涉及分布式事务。

多数本地事务情况下，只需要操作单一的数据库，这种情况下的事务称之为本地事务。本地事务的ACID特性数据库直接提供支持。

### 8.2 分布式事务场景

**1. 跨库事务**

​    跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据

**2. 分库分表**

​    通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。分别修改两个不同的分库，此时要保证两个库要不都成功，要不都失败。

**3. 微服务**

​    涉及到不同库操作，比较复杂后，会被拆分到不同的独立服务，独立服务之间通过RPC框架来进行远程调用，实现彼此的通信。需要保证跨服务的对多个数据库的操作要不都成功，要不都失败，最典型的分布式事务场景。



### 8.3 解决方案

#### 1. 两阶段提交（2PC）

两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

二阶段，将事务提交分为两个阶段，一阶段预执行SQL，二阶段，若一阶段执行失败，则回滚，否则提交。

如：下单场景，支付订单操作数据库时先将执行结果提交给协调者，然后再减库存，操作数据库，再将执行结果提交给协调者，二阶段时，判断如果一阶段有失败的，就会进行回滚，否则都提交commit，能够大大增加此次commit的成功率，但是也不能100%保证二阶段的commit能够成功。

**使用**  基于Java事务API（JTA：Java Transaction API）实现的框架atomikos

**可应用于** 分布式事务-跨库事务（需要同时操作多个数据库，保证一致性）

不使用分布式事务，微服务下

**不足**

- 单点故障，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作
- 数据不一致，阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。



#### 2. MQ事务消息-可靠消息最终一致性

**可靠消息最终一致性方案**

可靠性指消息一定会被发送到消费者端，消费成功后，返回到独立消息服务，保持最终一致性

**基于消息队列中间件**

不是所有的mq都支持事务消息（RocketMQ支持事务消息），也就是消息一旦发送到消息队列中，消费者立马就可以消费到。此时可以使用独立消息服务、或者本地事务表。

![独立消息服务](.\img\01_01.png)

1）将消息先发送到一个我们自己编写的一个"独立消息服务"应用中，刚开始处于prepare状态

2）业务逻辑处理成功后，确认发送消息，这个时候"独立消息服务"才会真正的把消息发送给消息队列

3）消费者消费成功后，ack时，除了对消息队列进行ack(图中没有画出)，还要对独立消息服务也进行ack

4）"独立消息服务"会通过定时消息状态确认，确认业务逻辑是否完成，完整后将会把消息发送至消息队列，发送至消费者端。所以即使第二步confirm消息未发送成功也不会影响后续流程。

5）第四步，当消息被发送至消费者端后，会存在定时任务定时去判断已经发送消息是否被消费成功，如果未消费成功，可以进行重发，因为消费者端可以会保持幂等性，可以重发。

6）第四步，消息发送至消费者，但是消息一直不处理不成功，重发也不成功，一直不会存在第五步，返回至独立消息服务，可以进行报警，然后进行人工处理。



**使用RocketMQ**

RocketMQ支持事务消息

![](.\img\01_02.png)

事务消息的逻辑，由发送端 Producer进行保证(消费端无需考虑)

​    首先，发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，注意此时这条消息消费者是无法消费到的。

​    接着，执行业务代码逻辑，可能是一个本地数据库事务操作

​    最后，确认发送消息，这个时候，RocketMQ将消息状态标记为可消费，这个时候消费者，才能真正的保证消费到这条数据。

​    如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了**消息发送与本地事务同时成功或同时失败**。

​    如果消费失败怎么办？提供解决方法是：人工解决

> 来源 http://www.tianshouzhi.com/api/tutorials/distributed_transaction/389

**整体思想**

相比于两段提交中的协调者，MQ事务消息方式中独立消息服务也扮演了协调者的角色，对处理结果进行汇总判断，采取不同处理方式。大体思想也是一致的。



## 9 什么是分布式CAP、BASE理论？

### 9.1 CAP理论

分布式系统需要保证各个节点同步，CAP理论即为关于该方面。

分布式系统三个特性，一致性（Consistency）,可用性（Availability），分区容错性（Partition-tolerance）,一个分布式系统最多只能满足其中两项。

**一致性**，用户通过web节点G1，和web节点G2，访问不同的节点，访问结果是一致的，即两个节点会进行数据同步。

**分区容错**，大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错时，区间通信可能失败。分布式系统中，因为难以保证，通常默认满足，若不满足无法保证多个节点的扩展。

![](.\img\01_03.png)

G1、G2可以理解为两个Web服务，需要通信保持数据一致性。但是由于网络故障或者其它原因，难以保证G1与G2通信一直正常，但是需要保证用户单独访问服务G1、服务G2，能够访问成功，即能够单独对外提供服务。分区容错在CAP中，必须要满足。

**可用性**，服务一直可用，而且是正常响应时间，系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。



### 9.2 一致性C和可用性A为什么不能保证同时成立？

一致性和可用性存在冲突矛盾。

**假设保证CA，不要求P**，那么多个节点间可能会存在通信失败，导致出现不一致或者不可用，因此不能扩容为多节点，多节点之间通信失败就会出现不一致或不可用，与分布式系统设计目的违背。因此分布式中通常需要满足P，而在CP或者AP中取舍。

**假设保证CP，不要求A**，保证数据一致性，不保证可用性，即每个请求都需要在服务器之间保持强一致，因此分区之间的数据同步，由于分区容错，可能耗时较长，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。

如zookeeper等，即为CP系统。

分布式事务JTA中，两阶段提交，强调一致性，导致可用性较低，通常使用不多。

**假设保证AP，不要求C**，保证可用性，不保证一致性，一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

如秒杀抢购场景，可能前几秒浏览商品的时候页面提示是有库存的，当选择完商品准备下单的时候，系统提示你下单失败，商品已售完。



### 9.3 BASE理论

由于CAP无法同时满足，会选择尽量靠近CAP定理，即尽量让C、A、P都满足，进行适当退让，因此出现BASE定理，包含三个方面。

#### 基本可用（Basically Available）

在系统出现故障时，运行损失部分可用性。

例如：响应时间上的损失，正常情况接口返回0.5秒，但是出现故障后，允许延迟到3秒内返回，但是更长时间就不能接受，损失部分可用性。

#### 软状态（Soft state）

硬状态指要求多个节点的数据副本都是一致的。

允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延迟。

#### 最终一致性（Eventually consistent）

强调所有数据更新操作，在经过一段时间同步之后，最终能够达到一个一致状态。本质是尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态，不需要实时保证数据的一致性。



## 10 TCC（Try-Confirm-Cancel）两阶段补偿方案

#### 场景

[1] 订单服务-修改订单状态，[2] 库存服务-扣减库存，[3] 积分服务-增加积分，[4] 仓储服务-创建销售出库单。

上述这几个步骤，要么一起成功，要么一起失败，必须是一个整体性的事务。

![](.\img\01_04.png)

#### TCC分布式事务方案

一阶段：提前预留需要修改的资源，单个接口的事务

二阶段：

​	1）如果一阶段预留都成功，二阶段进行确认资源（confirm）

![](.\img\01_05.png)

​	2）如果一阶段有失败的，二阶段进行回滚（cancel）。如果cancel阶段，回滚多次尝试失败，可能需要人工进行核对修改。

![](.\img\01_06.png)

#### 应用框架

ByteTCC、TCC-Transaction

#### 特点

相比于JTA，TCC锁粒度更小，变为指定服务接口的锁，更适合高并发场景。
















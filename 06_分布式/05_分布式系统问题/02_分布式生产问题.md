# 分布式系统生产问题

## 一 如何保证分布式接口幂等性问题

**是什么**

接口可重复调用，在重复调用多次情况下，接口能够保证结果是正确一致的。

如：重复下单、扣款接口等

**可能出现原因**

查询操作、删除操作天然幂等。

- 前端页面重复点击提交	
- 接口超时重试
- 消息重复消费

用户多次点击按钮；
用户页面回退再次提交；
微服务相互调用，由于网络原因，导致请求失败，feign触发重试机制；
其他业务情况；

**什么情况会出现幂等**

以SQl为例，有些操作时天然幂等。
select * from table where id =? 无论查询多少次都不会改变状态，是天然幂等的。
update table set col=1 where col2=2,无论执行操作多少次都不会改变状态，是天然幂等的。
delete from user where userId=1,多次操作，结果一样幂等操作。
inter into user(id,name)values(1,‘a’),如id唯一主键，即重复操作上面的业务，只会插入一条数据，具备幂等性；

update table1 set col1=col1+1 where col2=2,每次执行的结构都会发生变化，不是幂等。
inter into user(id,name)values(1,‘a’),如id不是主键，即重复操作上面的业务，会插入多条数据，不具备幂等性；

**常用解决方案**

- 唯一索引（全局唯一ID）

  接口下发时存在唯一ID，建立唯一索引。比如订单支付的orderId唯一，一个订单只能支付一次。唯一索引不允许表中任何两行具有相同索引值的索引。

  通常应用于需要create的操作。比如，创建支付订单、发货订单。

- 数据库去重表

  在处理请求时，先插入一个标识到数据库MySQL中，为唯一键，表明该请求已经被处理过，然后再进行业务处理，如果失败进行操作回滚。如果再重复提交，将不会被处理。

  该种方式如果没有执行成功，会导致再重复提交也不会进行处理。可以再优化为，如果执行成功再将标识写入到数据库中，这种方式会导致如果在处理请求过程中耗时较长，其它重复请求过来也会进行处理。可以再通过，业务执行成功，在插入到数据库去重表中发现重复处理了，然后进行回滚之前操作。

  也可以插入到redis中。

  标识的选择可以根据请求参数拼接生成，然后使用拦截器，拦截请求判断。

  通常应用于update的操作。比如更新库存。

- Token令牌

  每次请求生成请求唯一令牌，服务端对每个令牌进行生命周期管控，可以存储到redis中。规定时间内只允许一次请求，非第一次请求都属于重复提交。请求接口时，前端需要携带生成的令牌，后端处理时，先查看redis中对应令牌是否存在，已存在，则可以进行处理，先将令牌删除，然后再进行操作。重复请求也会进行令牌验证，若保存在服务端的令牌已不存在，则表示已有请求正在处理，不能再重复处理该请求。

- 状态机

  接口业务处理分为多个步骤，分别对应不同状态，采用有限状态机。如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，不能够变更，从而保证幂等性。

**总结**

保证幂等性需要结合实际业务场景，不同的方式都存在各自的不足。

**参考**

https://blog.csdn.net/weixin_42412601/article/details/108412439

## 二 如何保证分布式服务接口请求的顺序性？

**方式1** 采用hash将请求分配到同一个设备中

通过前端调用接口请求1、请求2、请求3时，按顺序下发至后端接入服务中，接入服务保证将该3个请求分发至同一台处理系统A中。系统A将3个请求，存入到同一个内存处理队列中，不同内存处理队列对应不同处理线程，每个线程只能处理一个内存队列中的请求，从而保证能够按顺序执行请求。

该种方式需要严格保证请求时按顺序下发，如果出现错乱，后续系统执行时，也不能保证顺序。

**方式2** 分布式锁

多个请求去竞争分布式锁，拿到锁后需要判断是不是能够执行，如果不能会释放锁，让其他请求先执行。



## 三 redis缓存使用问题

### 1 哪些数据适合放入缓存中

- 数据访问量大，但是更新频率不高的数据（即读多，写少的数据）
- 即时性、数据一致性要求不高的数据

缓存通常通过定时任务去更新或者是主动查询时不存在，再通过数据库查询到后写入缓存进行更新。

例如：电商类中的商品分类，商品列表等适合加入缓存，并配合失效时间使用，如后台发布一件商品后，缓存5分钟失效，5分钟后才能展示出来。

### 2 本地缓存

对于单体应用，可以使用，能够提高响应速度。

但是对于分布式系统，本地缓存会出现缓存数据不一致问题。

### 3  什么是缓存击穿、缓存穿透、缓存雪崩

- #### 缓存击穿

热点数据失效时，同时大量用户访问，请求全部达到数据库

**解决** 

1）设置热点数据永不过期，通过定时任务去定时更新

2）采用分布式锁

查询到数据为不存在时，为了避免同时大量请求直接都去查询数据库，此时需要加锁，查询一次数据库后，更新至缓存，其它在等待锁的请求，进来后先再查询一遍缓存，此时缓存里已存在，可以直接返回，不必查询数据库。

当从Redis中获取到数值为null时，需要从数据库中读取，先加锁然后再从数据库读取，读取完毕，释放锁。若其它线程，同时去请求相同key时，发现获取锁失败，则先睡眠一段时间（例如，100ms）后重试。

- #### 缓存穿透

采用不存在数据的请求，大量访问，缓存和数据库中都没有的数据，直接穿透一级、二级缓存，数据库，导致缓存失去意义，给数据库带来巨大压力。

**解决**

1） 布隆过滤器

一种数据结构，能够判断数据”一定不存在或者可能存在”。对于缓存击穿，将查询的数据条件哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了

> 什么是布隆过滤器
>
> 布隆过滤器是一个 bit 向量或者说 bit 数组：
>
> [布隆过滤器](https://zhuanlan.zhihu.com/p/43263751)

2） 对于不存在的数据的请求在redis中存放null值，然后设置过期时间（时间不易过长，避免获取不到最新数据，例如，30s）

3）业务层添加校验，对于非法的参数，进行校验，直接拦截返回

- #### 缓存雪崩

缓存的数据大面积同时失效，或者Redis宕机。

并发请求过多，redis无法响应请求，挂掉，大量请求直接访问到数据库（比如20w请求，redis能够支持1w，剩余直接去请求数据库）

**解决** 

1）采用redis集群更高可用或者

2）多级缓存

3）限流

4）可以通过将缓存失效时间设置为范围内的随机数，避免同时大量缓存同时失效

> Step1：保证redis集群高可用，采用多级缓存，接收到请求，先查找本地ehcache缓存，如果不存在再去查找redis，两者都不存在，再去查找数据库，然后将数据库中的结果写入ehcache和redis中
>
> Step2:  限流，使用Hystrix限流，比如同时8000个请求，限制每秒只能5000个请求通过，其余3000个没法通过，需要降级。能够保证数据库不会挂掉，仍然有部分请求能够处理。
>
> Step3: redis持久化，redis挂掉后，能够快速恢复缓存集群



### 4 出现了缓存失效、缓存穿透、缓存雪崩，如何及时去解决？



## 四 分布式锁是什么？如何实现分布式锁？ 

### 1 分布式锁是什么？

用来控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，一般需要通过一些互斥的手段来防止彼此之间的干扰，以保证一致性。

#### 为什么需要分布式锁

1） 部署的服务本身处于分布式环境中

2）保证效率，避免同个服务部署多个节点上，但是重复做了相同的工作，例如发送短信

3）保证正确性，对共享资源操作，需要保证安全，例如对库存扣减

#### 使用场景

例如：多用户下单购买同一个商品，下单请求发送到不同的机器上去，购买前查询库存充足，但当真正购买时发现库存不足，因此，需要分布式锁，来保证同一个商品同一时间只能由一个用户购买。

### 2 如何实现

两种方式，基于redis或者基于ZooKeeper。

**基于朴素redis方案**

**方式1** 直接使用`setnx+delete`

```java
setnx lock_key lock_value
// do sth
delete lock_key
```

实际应用

```java
    public Object getDataWithRedisLock() {
        // 使用分布式锁
        Boolean getLockSuccess = stringRedisTemplate.opsForValue().setIfAbsent("redis-lock", "111");
        if (!getLockSuccess) {
            // 加锁失败,先休息，后再重复获取
            TimeUnit.MILLISECONDS.sleep(100);
            return getDataWithRedisLock();
        } else {
            // 加锁成功
            // 执行业务....
            // 执行成功，释放锁
            stringRedisTemplate.delete("redis-lock");
            return result;
        }
    }
```

不足：服务获取锁后，执行业务，突然挂掉，锁无法释放

解决：设置过期时间

**方式2** 引入过期时间 `setnx + setex + delete`

```java
setnx lock_key lock_value
setex lock_key N lock_value  // N s超时
// do sth
delete lock_key
```

实际应用

```java
public Object getDataWithRedisLock() {
    // 使用分布式锁
    Boolean getLockSuccess = stringRedisTemplate.opsForValue().setIfAbsent("redis-lock", "111");
    if (!getLockSuccess) {
        // 加锁失败,先休息，后再重复获取
        TimeUnit.MILLISECONDS.sleep(100);
        return getDataWithRedisLock();
    } else {
        // 加锁成功
        // 设置过期时间
        stringRedisTemplate.expire("catalog-lock", 30, TimeUnit.SECONDS);
        // 执行业务....
        // 执行成功，释放锁
        stringRedisTemplate.delete("redis-lock");
        return result;
    }
}
```

不足：setnx + setex非原子操作，使用setnx获取锁后，还没来得及使用setex设置过期时间，服务挂掉，也会出现死锁

解决：使用原子命令

```java
public Object getDataWithRedisLock() {
    // 使用分布式锁
    Boolean getLockSuccess = stringRedisTemplate.opsForValue().setIfAbsent("redis-lock", "111", 30, TimeUnit.SECONDS);
    if (!getLockSuccess) {
        // 加锁失败,先休息，后再重复获取
        TimeUnit.MILLISECONDS.sleep(100);
        return getDataWithRedisLock();
    } else {
        // 加锁成功
        // 设置过期时间，非原子性
        // stringRedisTemplate.expire("catalog-lock", 30, TimeUnit.SECONDS);
        // 执行业务....
        // 执行成功，释放锁
        stringRedisTemplate.delete("redis-lock");
        return result;
    }
}
```

**方式3** 使用命令 `SET keyName randomValue NX EX 30000`

使用原生命令将加锁、设置超时两个步骤合并为一个原子操作

NX表示只有当keyName不存在时，才能设置成功，PX 30000表示30s后锁会自动释放。当同时其它线程来获取锁，如果没有设置成功就不能加锁。

不足：

1）  获取锁后，设置了10s过期时间，但是业务执行需要30s，执行阶段锁已经被释放

2）  30s后再去业务执行完，此时锁已被其它服务申请到，再去释放锁，会将其它其它服务申请到的锁错误释放掉，引起业务混乱

解决：

加锁时的value值，采用随机值UUID。

**方式4** 

针对3中的问题1，可以设置较长时间的过期时间，保证一定能够释放锁

针对3中的问题2，设置key值时使用随机值，在释放锁时，先判断对应key的value值，是不是自己申请锁时写入的value值，如果是，就进行释放，不是就再执行释放操作。为了保证判断操作原子性，需要使用lua脚本实现。如果不具备原子性，直接使用先去读取下key的value值，进行判断，若相同再进行释放，会出现一种情况，获取到key值，与释放之间的时间，key对应值，已经被其它服务修改了，那么再去释放锁，还是会释放掉别人的锁。

官方判断代码

>  lua脚本：https://redis.io/commands/eval

```java
if redis.call("get",KEYS[1]) == ARGV[1] then
   return redis.call("del",KEYS[1])
else
   return 0
5end
```

实际应用

```java
public Object getDataWithRedisLock() {
    // 使用分布式锁
    String uuid = UUID.randomUUID().toString();
    Boolean getLockSuccess = stringRedisTemplate.opsForValue().setIfAbsent("redis-lock", uuid, 30, TimeUnit.SECONDS);
    if (!getLockSuccess) {
        // 加锁失败,先休息，后再重复获取
        TimeUnit.MILLISECONDS.sleep(100);
        return getDataWithRedisLock();
    } else {
        // 加锁成功
        // 设置过期时间，非原子性
        // stringRedisTemplate.expire("redis-lock", 30, TimeUnit.SECONDS);
        try {
        	// 执行业务....
            return result;
        } finally {
            // 执行成功，释放锁
        	//stringRedisTemplate.delete("redis-lock");
            String script = "if redis.call('get',KEYS[1]) == ARGV[1] then  return redis.call('del',KEYS[1]) else return 0 end";
            stringRedisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList("redis-lock"), uuid);
        }       
    }
}
```

**总结**

方案3实现更为简单，如果能够保证设置最大过期时间的可靠，应该起来更为方便，也不易出现问题。

### 另一种描述

方式1

使用如下命令，NX表示只有当keyName不存在时，才能设置成功，PX 30000表示30s后锁会自动释放。当同时其它线程来获取锁，如果没有设置成功就不能加锁。

```java
SET keyName randomValue NX EX 30000
```

使用随机值是为了以安全的方式释放锁，当系统A获取到锁，但执行任务超过了超时时间，锁已经被释放了。系统B又获取到锁，此时系统A执行完任务，尝试去释放锁，此时不能释放锁，释放锁通过删除key，只有当密钥存在并且密钥中存储的值与获取锁时存入的随机值相等时才能删除锁，从而避免删除其它系统已经获取的锁。删除方法可以通过Lua脚本实现，删除时比较下随机值是否一致，不一致不能删除。

或者说该用户获得到锁后，可以每隔10s去检查这个锁是否还在被用户使用，如果没有使用完，刷新即将到期的30s时间，重新计算过期时间。避免了，因锁超时时间到了，未使用完就被释放了。这样会陷入循环，但是当客户端挂掉，客户端不会再去继续续约持有锁，因此也不会造成锁不能被释放。

不足之处，单个redis节点情况下，如果master redis挂掉，slave没有同步过来数据，可能导致两个用户同时加锁，出现问题。可以通过保证master、slave中同时写入成功，才算获得了锁。

方式2  redLock

redis集群场景，尝试在限定时间内为每个master节点创建锁，如果在时间内，能够为大多数节点设置锁成功，就表示建立锁成功。若建立失败，依次删除。

#### **基于ZooKeeper**

1）系统A尝试去ZooKeeper获取锁，通过创建一个临时节点，如果能够创建成功，就获取到了锁

2）ZooKeeper能够保证只有一个人可以获取到锁

3）系统B也尝试去获取同一名称的锁时，发现对应节点已经存在，表示已有其它系统占有锁，此时就对这个锁注册监听器

4）当系统A释放锁时，会去删除节点，系统B能够感知到，就可以尝试再获取锁

#### 使用redisson框架

> [redisson](https://github.com/redisson/redisson)官方文档

可以使用redisson框架，基于redis实现了一些开箱即用的高级功能，如分布式锁，可以直接使用。

##### 特点

1） 实现了多种锁，可重入锁、读写锁及闭锁、信号量等，使用方便

2）采用看门狗自动续期，写入redis锁，会设置过期时间30s，如果30s时间到，业务未执行完成，redisson会自动去进行续期为30s，避免了业务执行时间长，导致锁过期释放。

3）如果业务执行完成，超时时间到，也会自动释放锁，避免了服务突然崩溃死锁

##### 应用

```java
public Object getDataWithRedissonLock() {
    // 申请获取锁
    RLock lock = redisson.getLock("redis-lock");
    lock.lock();
    Object result = null;
    try {
        result = getDataFromDB();
    } finally {
        lock.unlock();
    }
    return result;
}
```

## 五 缓存一致性问题



## 五 如何设计一个高并发系统？

针对每秒1000个请求，需要考虑的点

1）系统拆分，

2）加缓存，读请求可以从缓存中获取（单击可以支持小于十万每秒的请求），写请求去访问数据库。（假如处理每秒6000请求）

3）加MQ，进行削峰，能够处理某个时段请求量特别大，MQ每秒消费1000个请求，大量请求积压在MQ中，保证高并发。（假如处理每秒1万请求）

4）分库分表，MQ需要每秒能够消费扩大至2000个请求，进行分库分表，每个库能够分摊处理请求压力。（假如处理每秒2W请求）

5）读写分离，请求中读多写少，数据库可以主从架构，主库写入，从库读取，进行读写分离。

6）搜索使用分布式搜索引擎elasticsearch



## 六 实际生产环境，分布式服务系统如何构建？

**需要从以下方面考虑**

技术选型：服务框架、注册中心、网关系统

如何配置：依据实际流量、高峰期，部署多少台设备，每台设备的硬件配置，每台能抗住多少流量

生产实践问题：服务之间的超时、重试、幂等、分布式锁

数据库配置部署

**实际部署情况**

通常情况，针对中小型系统，10~20个服务，每秒请求1000以内

1）注册中心

配置服务注册中心，多级缓存同步1s，服务拉取服务注册表频率为1s，服务心跳上报1s，服务故障发现，每隔1s检查一次，发现2s内服务没上报心跳，就任务故障。

2台设备，每台为4核8G，能够达到每秒几百至上千请求。

2）配置服务

每秒请求1000以内，每个服务可以部署2台机器，4核8G，

3）网关系统

4核8G，一台能够抗住每秒几百请求，部署3~4台，保证可用性

4）数据库

MySQL，16核32G设备，最多能抗住每秒几千请求，通常能达到每秒钟几十至几百请求。



## 七 查看系统每个服务每天请求量？高峰期流量？

框架：一些框架开放了端口号，访问这些端口号，能够获得统计结果

接口：可以在自己接口代码中加入一个计数AtomicLong，统计每天调用次数，然后使用日志打印出来。





## 八 分布式系统生产问题常见问题大类？

服务框架的选择、注册中心选择、网关系统、部署架构、缓存、超时重试、幂等性。

分布式事务、分布式锁。

# 分布式生产问题

## 一 如何保证分布式接口幂等性问题

**是什么**

接口可重复调用，在重复调用多次情况下，接口最终得到结果是一致的。

如：重复下单、扣款接口等

**可能出现原因**

- 前端页面重复点击提交	
- 接口超时重试
- 消息重复消费

**常用解决方案**

- 全局唯一ID

  接口下发时存在唯一ID，比如订单支付的orderId唯一，一个订单只能支付一次。

- 数据库去重表

  在处理请求时，先插入一个标识到数据库MySQL中，为唯一键，表明该请求已经被处理过，然后再进行业务处理，如果失败进行操作回滚。如果再重复提交，将不会被处理。

  也可以插入到redis中。

- 状态机

  接口业务处理分为多个步骤，分别对应不同状态，采用有限状态机。如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，不能够变更，从而保证幂等性。
  
  

## 二 如何保证分布式服务接口请求的顺序性？

**方式1** 采用hash将请求分配到同一个设备中

通过前端调用接口请求1、请求2、请求3时，按顺序下发至后端接入服务中，接入服务保证将该3个请求分发至同一台处理系统A中。系统A将3个请求，存入到同一个内存处理队列中，不同内存处理队列对应不同处理线程，每个线程只能处理一个内存队列中的请求，从而保证能够按顺序执行请求。

该种方式需要严格保证请求时按顺序下发，如果出现错乱，后续系统执行时，也不能保证顺序。

**方式2** 分布式锁

多个请求去竞争分布式锁，拿到锁后需要判断是不是能够执行，如果不能会释放锁，让其他请求先执行。



## 三 分布式锁是什么？如何实现分布式锁？ 

#### 是什么

用来控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，一般需要通过一些互斥的手段来防止彼此之间的干扰，以保证一致性。

#### 如何实现

两种方式，基于redis或者基于ZooKeeper。

**基于redis**

方式1

使用如下命令，NX表示只有当keyName不存在时，才能设置成功，PX 30000表示30s后锁会自动释放。当同时其它线程来获取锁，如果没有设置成功就不能加锁。

```java
SET keyName randomValue NX PX 30000
```

使用随机值是为了以安全的方式释放锁，当系统A获取到锁，但执行任务超过了超时时间，锁已经被释放了。系统B又获取到锁，此时系统A执行完任务，尝试去释放锁，此时不能释放锁，释放锁通过删除key，只有当密钥存在并且密钥中存储的值获取锁时存入的随机值时才能删除锁，从而避免删除其它系统已经获取的锁。删除方法可以通过Lua脚本实现，删除时比较下随机值是否一致，不一致不能删除。

不足之处，单个redis节点情况下，如果master redis挂掉，slave没有同步过来数据，会出现问题。

方式2  redLock

redis集群场景，尝试在限定时间内为每个master节点创建锁，如果在时间内，能够为大多数节点设置锁成功，就表示建立锁成功。若建立失败，依次删除。

**基于ZooKeeper**

1）系统A尝试去ZooKeeper获取锁，通过创建一个临时节点，如果能够创建成功，就获取到了锁

2）ZooKeeper能够保证只有一个人可以获取到锁

3）系统B也尝试去获取同一名称的锁时，发现对应节点已经存在，表示已有其它系统占有锁，此时就对这个锁注册监听器

4）当系统A释放锁时，会去删除节点，系统B能够感知到，就可以尝试再获取锁



## 四 如何设计一个高并发系统？

针对每秒1000个请求，需要考虑的点

1）系统拆分，

2）加缓存，读请求可以从缓存中获取（单击可以支持小于十万每秒的请求），写请求去访问数据库。（假如处理每秒6000请求）

3）加MQ，进行削峰，能够处理某个时段请求量特别大，MQ每秒消费1000个请求，大量请求积压在MQ中，保证高并发。（假如处理每秒1万请求）

4）分库分表，MQ需要每秒能够消费扩大至2000个请求，进行分库分表，每个库能够分摊处理请求压力。（假如处理每秒2W请求）

5）读写分离，请求中读多写少，数据库可以主从架构，主库写入，从库读取，进行读写分离。

6）搜索使用分布式搜索引擎elasticsearch
























































































































### 一 JVM内存结构，Java内存模型，Java对象模型分别指什么

- **JVM内存结构**（也有叫作Java内存区域、Java内存结构等）

主要用来描述JVM内存管理机制中，JVM将内存主要分为：虚拟机栈、本地方法栈、堆、方法区和程序计数器。

- **Java内存模型**

主要用来描述程序中各个变量的访问规则，即在虚拟机中将变量（指实例字段、静态字段、构成数组对象的元素）存储到内存或从内存中取出的底层细节。

- **Java对象模型**

主要描述JVM中，对象如何创建、对象的内存布局（对象在内存中如何存放）、如何访问。



### 二 JVM内存结构？

用来描述JVM内存管理机制，当一个类.class文件通过类加载机制加载进JVM内存中，它如何在内存中存放，哪些信息该放在哪个区域，在代码执行时如何获取的，JVM内存结构主要用来解决这个事情。主要包含以下几个区域

- 虚拟机栈

虚拟机栈表示的是Java类中方法执行时会在虚拟机栈中创建一个栈帧，压入虚拟机栈中，方法执行完后再出栈，每个方法都会对应一个栈帧。栈帧里用来存放方法中声明的局部变量表，操作数栈，动态链接和方法入口等信息。每个方法执行完，都会在虚拟机栈中有个进栈和出栈的过程。

![虚拟机栈描述](.\img\02\02_01.PNG)

**局部变量表**，容易理解，存放方法中局部变量，包含基本数据类型，对象的引用（局部变量也会有对象变量）等

**操作数栈**，程序运行时，操作数临时中转的区域，比如需要完成a=1的操作，会有操作iconst_1（将int型常量1压入操作数栈），istore_1（将int型常量压入局部变量表）这些操作数过程，操作数栈也对应着操作指令的进栈和出栈过程。

**动态链接**，在方法中还会调用其他方法，如何定位到其它方法所在位置，即通过动态链接。程序运行时，方法中再调用另一个方法，会先根据方法区的常量池中加载的类信息找到类对象头中的类型指针，找到对应方法内存地址，然后获取指令码执行，对应方法的内存地址就指动态链接。

**方法返回地址**，即返回方法被调用的地方。

- 本地方法栈

本地方法栈用来存放Native方法，Native方法可能调用的为由其他语言编写的动态链接库，通过JNI调用。

- 堆

在虚拟机栈的栈帧中的局部变量表中对于对象，放的是对象的引用，那实际的对象内容存放在哪个区域？堆中。

堆存放几乎所有实例对象，由垃圾回收器自动回收，所有线程共享。

- 方法区（也称作永久代，在Java8中称作元空间）

加载类后，方法中信息存放在虚拟机栈中，类中声明的变量，常量，这些信息放在哪里呢？方法区。

方法区用于存储被加载的类元信息（Klass，类的结构信息如类的版本、字段，有哪些方法等信息，在对象头中的类型指针Klass Pointer即指向该位置）、常量、静态变量、即时编译后代码等。

在Java8中，方法区使用的内存为直接内存，是物理内存，为JVM占用的内存以外的本地内存。

- 程序计数器

线程私有，用于记录当前线程代码（指字节码）执行位置。

### 三 关于堆区的垃圾回收

堆存放几乎所有实例对象，由垃圾回收器自动回收，所有线程共享。

![堆的垃圾回收](.\img\02\02_02.PNG)

采用复制算法

堆中主要分为两个区域，新生代和老年代。新生代包含Eden区和两个Survivor区，新生代默认会占内存的1/3，老年代占2/3。当对象刚创建后存放在新生代的Eden区，当Eden区满后，会触发Young GC，对Eden区进行清除，没有被引用的对象直接回收，依然存活的对象会被移动到Survivor区，Survivor分为S0和S1两块区域。Survivor区在进行Young GC时也会进行清除，将Eden区移过来的，和正在使用的S0（假如在使用S0），复制到另一块未使用的空间S1，然后将当前正在使用的空间S0清除掉，然后切换S1为使用状态，此时Eden区和S0空间都被释放掉。如果Young GC回收的对象大于Survivor区，会直接进入老年代。是不是对象可以一直在S0或者S1进行交换？不是，每个对象都会有一个计数器（存放在对象的对象头中），每次触发Young GC都会加1，通过参数`-XX:MaxTenuringThreashold`参数能够配置计数器值，如果设置为1，那么触发一次Young GC就会进入老年代，该值默认配置为15。

如果老年代也无法放下，那么会触发Full GC，如果再放不下，则会抛出OOM。

通过visual GC插件，可以看到整个过程。

![VisualGC](.\img\02\02_03.PNG)

### 四 类加载机制

#### 4.1 类加载过程？

主要分为三个阶段，加载、链接（验证、准备、解析），初始化。

- 加载，读取class文件的二进制流，生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据入口（就是说加载进来放在了方法区的一块地方，通过生成的对象，能够找到这个类的信息）
- 链接-验证，更详细的校验Class文件，字节流中的内容是否符合虚拟机要求
- 链接-准备，为静态变量（指静态变量）分配内存，并赋予该数据类型的零值（如`public static int value = 123`，赋予的值是0，而不是123）
- 链接-解析，解析类和方法，确保类与类之间相互引用正确
- 初始化，执行类构造器的<clinit>方法（包括类变量的赋值操作和静态语句块操作。）



#### 4.2 类加载器如何定位到具体的类文件并进行读取的？

**类加载器作用**：加载class文件

**类加载器分类**

- 启动类加载器（Bootstrap ClassLoader），加载Java核心类，主要为/jre/lib/rt.jar等
- 扩展类加载器（Extension ClassLoader），在Java9改为平台类加载器（Platform ClassLoader）。加载一些扩展类，位于目录/jre/lib/ext/*.jar下jar等
- 应用类加载器（Application ClassLoader），用户自定义的CLASSPATH路径下类

**加载类时使用双亲委派模型，过程如下**

- 类加载器接收到类加载的请求，**判断该类是否已被加载过？（若被加载过，直接返回）** **若没有，自身是否可以去加载?**
- 逐级向上询问，直至启动类加载器，若启动类加载器也未加载过且不能加载，那么会逐级往下通知子加载器进行加载
- 加载不到则会报ClassNotFoundException



**例子**

比如用户自定义一个java.lang.String类，写入自己的方法，能够被成功加载执行吗？

不行。基于双亲委派模型，应用类加载器会先判断两个问题，我是否已经加载过该类，我可以加载此类吗？因此会依次向高层次类加载器进行询问，到达启动类加载器时，发现已加载过JVM自己的java.lang.String类，因此不会再加载，所以用户自定义的java.lang.String类不会被加载，会报错。



#### 4.3 如何自定义类加载器？

可以通过继承ClassLoader类，重写findClass()方法，来自定义类加载器。

通过自定义类加载器能够修改类加载的方法，隔离加载类等，从而避免类冲突。



#### 4.4 对象实例化过程

new对象时实际过程

- 确认类元信息是否存在。在元空间查看类元信息是否存在，若不存在，通过双亲委派模型，进行加载
- 分配对象内存。在堆中分配内存
- 设定默认值。设定成员变量初始化零值
- 设置对象头。设置新对象的对象头（包含哈希码、GC信息、锁信息、对象类元信息）
- 执行初始化方法。初始化成员变量，执行实例化代码块，调用类的构造方法，堆内对象首地址赋值给引用变量。



#### 4.5 OGSI加载机制



### 五 垃圾回收机制

#### 5.1 垃圾回收的主要作用？垃圾回收的位置？

GC主要作用是清除不再使用的对象，自动释放内存。

垃圾回收主要是堆和方法区。



#### 5.2 GC如何判断哪些对象可以被回收？

**引用计数法**：给每个对象一个引用计数器，当被引用时计数器加1，引用失效时，计数器减1，当为0时，可以被回收。无法解决循环引用的问题，JVM未采用该种方式。

**可达性分析（即通过GC Roots）**：如果一个对象与GC Roots之间，没有直接或间接的引用关系，比如某个对象失去了任何引用，或者是两个对象循环引用等。



#### 5.3 哪些对象可以被选做GC Roots？

- 虚拟机栈的栈帧中的本地方法表中引用的对象（方法中声明的局部变量）

- 位于方法区中类静态属性中引用的对象（就是类中声明的静态变量用的对象）
- 方法区中常量引用的对象（常量）

- 本地方法栈中引用的对象（native方法）



#### 5.4 常见的GC算法有哪些？

包含标记-清除算法，标记-整理算法和复制算法。

- 标记-清除算法（适用于老年代）

触发GC后，从GC Roots出发，依次标记出被引用的对象，最后清除没有被标记的对象。

缺点：会造成大量空间碎片，当需要一块大的空间时，会容易触发Full GC。

- 标记-整理算法（适用于老年代）

从GC Roots出发，依次标记出存在引用关系的对象，将这些存活的对象整理到内存的另一端，形成内存连续空间，最后将另一部分清除掉，不会产生空间碎片。

缺点：需要额外的分配空间担保。

- 复制算法（主流的Young GC算法，作为新生代的垃圾回收）

将堆空间分为较大的Eden区和两块Survivor区，每次只使用Eden区和Survivor区中的一块。新对象创建时存储在Eden区，当Eden区满，执行YGC，将存活对象复制到Survivor区中一块（假设为S0），清空Eden区。当Eden区再满后，进行YGC，再标记出Eden区和S0中的存活对象，复制到另一块S1中，释放Eden区和S0区，使用S1区，如此循环。

**分配比例**：Eden区和Survivor区默认为8:1。新生代和老年代为1:2。

**优点**：避免了空间碎片问题。



#### 5.5 常见垃圾回收器有哪些？

**垃圾回收器是应用垃圾回收算法实现的内存管理模块**，主要四种Serial、Parallel、CMS、G1。

Java8默认采用并行多线程收集器，Parallel Scavenge (新生代，采用复制算法) 和 Parallel Old (老年代，采用标整理算法)

- **Serial（串行收集器）**

采用串行单线程方式完成GC任务，垃圾回收的某个阶段会暂停整个应用程序进行垃圾回收（称为STW，stop the world），此时只要一个线程来完成GC任务。

特点：单线程，会暂停用户线程。不适合服务器端。

- **Parallel（并行垃圾收集器）**

Serial收集器的多线程版本，在STW时，有多个线程来完成GC任务。

特点：多线程，会暂停用户线程，适用于计算，数据处理等。

- **CMS（并发标记清除收集器，Concurrent Mark Sweep Collector）（配置参数 `-XX:UseConcMarkSweepGC` ）**

四个步骤，通过初始标记（标记与GC Roots直接相连的对象，单线程），并发标记（并发标记存活对象），重新标记，并发清除。

初始标记和重新标记也会引发STW，但时间较短。并发标记和并发清除，耗时较长，但能够与用户线程并发执行。

特点：CMS采用并发-标记算法，也会产生空间碎片，但低延时，能够快速响应，用于老年代。

与ParNew配合使用。

![CMS垃圾回收](.\img\02\02_06.PNG)

PS：  [CMS在Java9中已被不推荐使用，后续将被移除](https://bugs.openjdk.java.net/browse/jdk-8229049)

- **G1**





#### 5.6 如何查看服务器默认的垃圾收集器？如何配置垃圾收集器？默认的垃圾回收器有哪些?

**查看默认垃圾收集器**：`-XX:+PrintCommandLineFlags -version`，查看JVM初始默认配置参数

**配置垃圾收集器**：通过配置参数  `-XX:UseSerialGC`     `-XX:UserParallelGC`  `-XX:UseConcMarkSweepGC`  `-XX:UseG1GC`等配置

**默认垃圾回收器组合**：以下7种，连线表示新生代和老年代的垃圾回收器组合

![默认垃圾收集器组合](.\img\02\02_04.PNG)

**总结**：

![配置垃圾回收器](.\img\02\02_05.PNG)



#### 5.7 G1垃圾回收器

**历程**：

![G1收集器历程](E:/tt%E6%96%87%E6%A1%A3/%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3/ttGit/JavaInterview/img/02/02_07.PNG)

整体思想：化整为零，分而治之

**特点**：

- 把内存划分为多个独立，大小相同的子区域，包含Eden、Survivor（幸存区）、Old区和Hummongus。
- 分代收集，G1不再从物理上区分新生代和老年代（就是说一个区域可以在新生代和老年代变换），
- 整体上采用标记-整理算法，多个区块之间采用复制算法，都不会产生内存空间碎片
- 可预测的停顿，STW可控，用户可以指定期望停顿时间
- 用于替代CMS，Java9+默认GC

![G1区域划分](.\img\02\02_10.PNG)

**原理**：

- 将堆分成若干个大小相等的子区域，默认2048块（通过参数`-XX:G1HeapRegionSize=N`设置每块区域大小，范围在1MB-32MB，因此最大为32M*2048=64G），回收时不回收整个堆，选择一个区域集合Collection Set(CS)  
- 每个区可以表示为Eden、Survivor（幸存区）、Old区和Hummongus，Hummongus也为老年代区域，当分配到很大对象，直接放在该区域
- 对象的存储在物理内存上不要求一定是连续的，只要逻辑上连续即可，每个分区可以在新生代和老年代之间切换
- G1中包含两种GC，一种全部的YGC（Fully young GC） 和混合GC（Mixed GC）

**回收过程（4步）**：类似CMS

- 初始标记，标记出与GC Roots直接关联的对象
- 并发标记，从GC Roots开始，采用三色标记法，标记出存活对象（耗时较长，但能够与用户程序并发运行）
- 最终标记，修正并发标记期间，由于用户线程继续运行导致标记产生变化的那部分对象
- 筛选回收，根据期望时间制定回收计划

![G1垃圾回收流程](.\img\02\02_09.PNG)

**G1回收机制遇到的典型问题**：

- 老年代对象可能持有年轻代的引用（跨代引用）

- 不同region之间互相引用

![跨代引用](.\img\02\02_11.PNG)

每个Region按照512个字节，分为若干个卡片，在每个Region中，都再对应一个Remembered Set，当卡片中存在引用时，会记录在对应Remembered Set中。因此在回收区域时，读取Remembered Set可以知道哪些卡片在引用我，只需要去扫描对应卡片的对象，避免了整个堆的扫描，提高了效率，典型空间换时间。

![跨代引用](.\img\02\02_12.PNG)



#### 5.8 G1垃圾回收器与CMS对比，有什么区别？

- G1不会产生内存碎片，CMS采用标记-清除会存在碎片
- G1用户可以指定期望停顿时间



#### 5.9 GC调优步骤

1. 收集GC日志，运行时添加-`XX:+PrintGCDetails -XX:+PrintGCTimeSTamps -XX:+PrintGCDateStamps -Xloggc:./gc.log`

2. 分析日志得到关键性能指标
3. 分析GC原因，调优JVM参数



#### 5.10 什么时候触发Young GC?如何触发Full GC？

对象创建时，会存放在新生代Eden区

大对象会直接进入老年代

长期存活的对象（触发一次YGC，会+1，默认15次）将进入老年代



- YGC，当新生代满了后会触发Young GC，新生代对象存生存期短，发生GC频率高
- Full GC，老年代满了后，会触发Full GC（也会是要往老年代放对象，放不下的时候），在Full GC前触发一次YGC，能够加快老年代的回收

对象



#### 5.11 JVM常用的配置参数有哪些？（或者是你用过哪些JVM配置参数？）

回答以下常用参数即可

`-Xms`  等价于 `-XX:InitialHeapSize=`    设置初始堆内存，默认为1/64

`-Xmx`  等价于  `-XX:MaxHeapSize=`   最大堆内存 ，默认为物理内存的1/4

`-Xss`  等价于 `-XX:ThreadStackSize=`  设置单个线程栈大小，通常默认为512k-1024k，依赖于平台

`-XX:MetaspaceSize=128m`  设置元空间大小，元空间与永久代类似，Java8后成为元空间，元空间内存使用本地内存，因此元空间本地大小也依赖于本地内存大小，也可通过此参数设置

`-XX:+PrintGCDetails`     打印GC详细信息



以下为补充

（JVM参数类型主要分为标配参数、X参数和XX参数。主要需要知道XX参数。）

Jvm参数主要是以XX开头

- boolean型   `-XX:+或者-`，+表示在使用，-表示关闭

`-XX:+PrintGCDetails` 打印GC信息

- key/value型 设置类型，设置具体值，-XX:属性key=属性值value

`-XX:MetaspaceSize=128m`  设置元空间大小

`-XX:MaxTenuringThreashold=15`   设置年轻代进入老年代，进行YGC个数

`-Xms`  等价于 `-XX:InitialHeapSize=`    设置初始堆内存

`-Xmx`  等价于  `-XX:MaxHeapSize=`   最大堆内存  



- 查看JVM默认参数值

方法1

通过jps查看Java的进程号，再通过`jinfo -flag Metaspacesize 27008`，能够查看该参数配置情况

方法2

`java -XX:+PrintFlagsInitial`   直接查看所有初始参数

`java -XX:+PrintFlagsFinal`    可以查看JVM修改过的参数，用了`:=`标出

`java -XX:+PrintCommandLineFlags`    打印JVM默认采用的优化参数



#### 5.12 GC日志查看

- Young GC

![GC日志](.\img\02\02_13.PNG)



#### 5.13 强引用、软引用、弱引用、虚引用指什么？(强软弱虚)

- 强引用

把一个对象赋给一个引用变量，这个引用变量就是一个强引用。 

垃圾回收，对于强引用的对象，即使出现了OOM，也不会对该进行回收

- 软引用

当系统充足时，不会被回收，内存不足时，会被回收。高速缓存。

通过SoftReference类实现

- 弱引用

弱引用关联对象，在下一次垃圾回收发生时，都会被回收

通过WeekReference类实现

应用：WeakHashMap，当触发GC，map中元素会被回收，应用于缓存

- 虚引用

对象持有虚引用，不会对对象的生存有任何影响，需要与引用队列一起使用。

虚引用的主要作用是跟踪对象被垃圾回收的状态 。



#### 5.14 深拷贝、浅拷贝分别指什么？





#### 5.15 JVM常用性能监控工具，怎么用？

- 虚拟机Java进程监视工具（jps），
- Java配置信息工具（jinfo），
- 内存映像工具（jmap）,
- 统计信息监视工具（jstat）,
- 堆栈异常跟踪工具（jstack），
- jvisualvm
- jconsole





#### 5.16 服务器变慢，可通过哪些命令分析？

- 查看整机系统性能：top 命令，看cpu、内存使用率，系统平均负载（load average，）
- 查看CPU：vmstat命令、pidstat命令
- 查看内存：free
- 查看硬盘：df
- 查看磁盘IO：iostat
- 查看网络IO：ifstat



#### 5.17 系统CPU使用率过高，定位分析思路？

能结合Linux和JDK命令一起分析，定位出是哪个线程，哪行代码出现问题

